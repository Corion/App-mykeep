{"version":3,"file":"workbox-routing.prod.js","sources":["packages/workbox-routing/_version.mjs","packages/workbox-routing/utils/normalizeHandler.mjs","packages/workbox-routing/Route.mjs","packages/workbox-routing/utils/constants.mjs","packages/workbox-routing/RegExpRoute.mjs","packages/workbox-routing/Router.mjs","packages/workbox-routing/NavigationRoute.mjs","packages/workbox-routing/_default.mjs","packages/workbox-routing/browser.mjs"],"sourcesContent":["try{self.workbox.v['workbox:routing:3.0.0-alpha.1']=1;}catch(e){} // eslint-disable-line","/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport '../_version.mjs';\n\n/**\n * @param {function|Object} handler Either a function, or an object with a\n * 'handle' method.\n * @return {Object} An object with a handle method.\n *\n * @private\n */\nexport default (handler) => {\n  if (handler && typeof handler === 'object') {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.hasMethod(handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return handler;\n  } else {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(handler, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'handler',\n      });\n    }\n    return {handle: handler};\n  }\n};\n","/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\n\nimport {defaultMethod, validMethods} from './utils/constants.mjs';\nimport normalizeHandler from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * A `Route` consists of a pair of callback functions, \"match\" and \"handler\".\n * The \"match\" callback determine if a route should be used to \"handle\" a\n * request by returning a non-falsy value if it can. The \"handler\" callback\n * is called when there is a match and should return a Promise that resolves\n * to a `Response`.\n *\n * @memberof workbox.routing\n */\nclass Route {\n  /**\n   * Constructor for Route class.\n   *\n   * @param {workbox.routing.Route~matchCallback} match\n   * A callback function that determines whether the route matches a given\n   * `fetch` event by returning a non-falsy value.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resolving to a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(match, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(match, 'function', {\n        moduleName: 'workbox-routing',\n        className: 'Route',\n        funcName: 'constructor',\n        paramName: 'match',\n      });\n\n      if (method) {\n        assert.isOneOf(method, validMethods, {paramName: 'method'});\n      }\n    }\n\n    // These values are referenced directly by Router so cannot be\n    // altered by minifification.\n    this.handler = normalizeHandler(handler);\n    this.match = match;\n    this.method = method || defaultMethod;\n  }\n}\n\nexport {Route};\n","/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport '../_version.mjs';\n\n/**\n * The default HTTP method, 'GET', used when there's no specific method\n * configured for a route.\n *\n * @type {string}\n *\n * @private\n */\nexport const defaultMethod = 'GET';\n\n/**\n * The list of valid HTTP methods associated with requests that could be routed.\n *\n * @type {Array<string>}\n *\n * @private\n */\nexport const validMethods = [\n  'DELETE',\n  'GET',\n  'HEAD',\n  'POST',\n  'PUT',\n];\n","/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from './Route.mjs';\nimport './_version.mjs';\n\n/**\n * RegExpRoute makes it easy to create a regular expression based\n * [Route]{@link workbox.routing.Route}.\n *\n * For same-origin requests the RegExp only needs to match part of the URL. For\n * requests against third-party servers, you must define a RegExp that matches\n * the start of the URL.\n *\n * [See the module docs for info.]{@link https://developers.google.com/web/tools/workbox/v3/modules/workbox-routing}\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass RegExpRoute extends Route {\n  /**\n   * If the regulard expression contains\n   * [capture groups]{@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#grouping-back-references},\n   * th ecaptured values will be passed to the\n   * [handler's]{@link workbox.routing.Route~handlerCallback} `params`\n   * argument.\n   *\n   * @param {RegExp} regExp The regular expression to match against URLs.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   */\n  constructor(regExp, handler, method) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(regExp, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'RegExpRoute',\n        funcName: 'constructor',\n        paramName: 'pattern',\n      });\n    }\n\n    const match = ({url}) => {\n      const result = regExp.exec(url.href);\n\n      // Return null immediately if there's no match.\n      if (!result) {\n        return null;\n      }\n\n      // Require that the match start at the first character in the URL string\n      // if it's a cross-origin request.\n      // See https://github.com/GoogleChrome/workbox/issues/281 for the context\n      // behind this behavior.\n      if ((url.origin !== location.origin) && (result.index !== 0)) {\n        if (process.env.NODE_ENV !== 'production') {\n          logger.debug(\n            `The regular expression '${regExp}' only partially matched ` +\n            `against the cross-origin URL '${url}'. RegExpRoute's will only ` +\n            `handle cross-origin requests if they match the entire URL.`\n          );\n        }\n\n        return null;\n      }\n\n      // If the route matches, but there aren't any capture groups defined, then\n      // this will return [], which is truthy and therefore sufficient to\n      // indicate a match.\n      // If there are capture groups, then it will return their values.\n      return result.slice(1);\n    };\n\n    super(match, handler, method);\n  }\n}\n\nexport {RegExpRoute};\n","/*\n Copyright 2017 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {getFriendlyURL} from 'workbox-core/_private/getFriendlyURL.mjs';\n\nimport normalizeHandler from './utils/normalizeHandler.mjs';\nimport './_version.mjs';\n\n/**\n * The Router can be used to process a FetchEvent through one or more\n * [Routes]{@link workbox.routing.Route} responding  with a Request if\n * a matching route exists.\n *\n * If no route matches a given a request, the Router will use a \"default\"\n * handler if one is defined.\n *\n * Should the matching Route throw an error, the Router will use a \"catch\"\n * handler if one is defined to gracefully deal with issues and respond with a\n * Request.\n *\n * If a request matches multiple routes, the **earliest** registered route will\n * be used to respond to the request.\n *\n * @memberof workbox.routing\n */\nclass Router {\n  /**\n   * Initializes a new Router.\n   */\n  constructor() {\n    // _routes will contain a mapping of HTTP method name ('GET', etc.) to an\n    // array of all the corresponding Route instances that are registered.\n    this._routes = new Map();\n  }\n\n  /**\n   * Apply the routing rules to a FetchEvent object to get a Response from an\n   * appropriate Route's handler.\n   *\n   * @param {FetchEvent} event The event from a service worker's 'fetch' event\n   * listener.\n   * @return {Promise<Response>|undefined} A promise is returned if a\n   * registered route can handle the FetchEvent's request. If there is no\n   * matching route and there's no `defaultHandler`, `undefined` is returned.\n   */\n  handleRequest(event) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isInstance(event, FetchEvent, {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'handleRequest',\n        paramName: 'event',\n      });\n    }\n\n    const url = new URL(event.request.url);\n    if (!url.protocol.startsWith('http')) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n          `Workbox Router only supports URLs that start with 'http'.`);\n      }\n      return;\n    }\n\n    let route = null;\n    let handler = null;\n    let params = null;\n    let debugMessages = [];\n\n    const result = this._findHandlerAndParams(event, url);\n    handler = result.handler;\n    params = result.params;\n    route = result.route;\n    if (process.env.NODE_ENV !== 'production') {\n      if (handler) {\n        debugMessages.push([\n          `Found a route to handle this request:`, route,\n        ]);\n\n        if (params) {\n          debugMessages.push([\n            `Passing the following params to the route's handler:`, params,\n          ]);\n        }\n      }\n    }\n\n    // If we don't have a handler because there was no matching route, then\n    // fall back to defaultHandler if that's defined.\n    if (!handler && this._defaultHandler) {\n      if (process.env.NODE_ENV !== 'production') {\n        debugMessages.push(`Failed to find a matching route. Falling ` +\n          `back to the default handler.`);\n\n        // This is used for debugging in logs in the case of an error.\n        route = '[Default Handler]';\n      }\n      handler = this._defaultHandler;\n    }\n\n    if (!handler) {\n      if (process.env.NODE_ENV !== 'production') {\n        // No handler so Workbox will do nothing. If logs is set of debug\n        // i.e. verbose, we should print out this information.\n        logger.debug(`No route found for: ${getFriendlyURL(url)}`);\n      }\n      return;\n    }\n\n    if (process.env.NODE_ENV !== 'production') {\n      // We have a handler, meaning Workbox is going to handle the route.\n      // print the routing details to the console.\n      logger.groupCollapsed(`Router is responding to: ${getFriendlyURL(url)}`);\n      debugMessages.forEach((msg) => {\n        if (Array.isArray(msg)) {\n          logger.log(...msg);\n        } else {\n          logger.log(msg);\n        }\n      });\n\n      // The Request and Response objects contains a great deal of information,\n      // hide it under a group in case developers want to see it.\n      logger.groupCollapsed(`View request details here.`);\n      logger.unprefixed.log(event.request);\n      logger.groupEnd();\n\n      logger.groupEnd();\n    }\n\n    // Wrap in try and catch in case the handle method throws a synchronous\n    // error. It should still callback to the catch handler.\n    let responsePromise;\n    try {\n      responsePromise = handler.handle({url, event, params});\n    } catch (err) {\n      responsePromise = Promise.reject(err);\n    }\n\n    if (responsePromise && this._catchHandler) {\n      responsePromise = responsePromise.catch((err) => {\n        if (process.env.NODE_ENV !== 'production') {\n          // Still include URL here as it will be async from the console group\n          // and may not make sense without the URL\n          logger.groupCollapsed(`Error thrown when responding to: ` +\n            ` ${getFriendlyURL(url)}. Falling back to Catch Handler.`);\n          logger.unprefixed.error(`Error thrown by:`, route);\n          logger.unprefixed.error(err);\n          logger.groupEnd();\n        }\n        return this._catchHandler.handle({url, event, err});\n      });\n    }\n\n    return responsePromise;\n  }\n\n  /**\n   * Checks the incoming `event.request` against the registered routes, and if\n   * there's a match, returns the corresponding handler along with any params\n   * generated by the match.\n   *\n   * @param {FetchEvent} event\n   * @param {URL} url\n   * @return {Object} Returns an object with `handler` and `params` properties.\n   * They are populated if a matching route was found or `undefined` otherwise.\n   *\n   * @private\n   */\n  _findHandlerAndParams(event, url) {\n    const routes = this._routes.get(event.request.method) || [];\n    for (const route of routes) {\n      let matchResult = route.match({url, event});\n      if (matchResult) {\n        if (Array.isArray(matchResult) && matchResult.length === 0) {\n          // Instead of passing an empty array in as params, use undefined.\n          matchResult = undefined;\n        } else if ((matchResult.constructor === Object &&\n          Object.keys(matchResult).length === 0) || matchResult === true) {\n          // Instead of passing an empty object in as params, use undefined.\n          matchResult = undefined;\n        }\n\n        // Break out of the loop and return the appropriate values as soon as\n        // we have a match.\n        return {\n          route,\n          params: matchResult,\n          handler: route.handler,\n        };\n      }\n    }\n\n    // If we didn't have a match, then return undefined values.\n    return {handler: undefined, params: undefined};\n  }\n\n  /**\n   * Define a default `handler` that's called when no routes explicitly\n   * match the incoming request.\n   *\n   * Without a default handler, unmatched requests will go against the\n   * network as if there were no service worker present.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setDefaultHandler(handler) {\n    this._defaultHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * If a Route throws an error while handling a request, this `handler`\n   * will be called and given a chance to provide a response.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   */\n  setCatchHandler(handler) {\n    this._catchHandler = normalizeHandler(handler);\n  }\n\n  /**\n   * Registers a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to register.\n   */\n  registerRoute(route) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(route, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route, 'match', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.isType(route.handler, 'object', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route',\n      });\n\n      assert.hasMethod(route.handler, 'handle', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.handler',\n      });\n\n      assert.isType(route.method, 'string', {\n        moduleName: 'workbox-routing',\n        className: 'Router',\n        funcName: 'registerRoute',\n        paramName: 'route.method',\n      });\n    }\n\n    if (!this._routes.has(route.method)) {\n      this._routes.set(route.method, []);\n    }\n\n    // Give precedence to all of the earlier routes by adding this additional\n    // route to the end of the array.\n    this._routes.get(route.method).push(route);\n  }\n\n  /**\n   * Unregisters a route with the router.\n   *\n   * @param {workbox.routing.Route} route The route to unregister.\n   */\n  unregisterRoute(route) {\n    if (!this._routes.has(route.method)) {\n      throw new WorkboxError(\n        'unregister-route-but-not-found-with-method', {\n          method: route.method,\n        }\n      );\n    }\n\n    const routeIndex = this._routes.get(route.method).indexOf(route);\n    if (routeIndex > -1) {\n      this._routes.get(route.method).splice(routeIndex, 1);\n    } else {\n      throw new WorkboxError('unregister-route-route-not-registered');\n    }\n  }\n}\n\nexport {Router};\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport {Route} from './Route.mjs';\nimport './_version.mjs';\n\n/**\n * NavigationRoute makes it easy to create a [Route]{@link\n * workbox.routing.Route} that matches for browser\n * [navigation requests]{@link https://developers.google.com/web/fundamentals/primers/service-workers/high-performance-loading#first_what_are_navigation_requests}.\n *\n * It will only match incoming Requests whose\n * [`mode`]{@link https://fetch.spec.whatwg.org/#concept-request-mode}\n * is set to `navigate`.\n *\n * You can optionally only apply this route to a subset of navigation requests\n * by using one or both of the `blacklist` and `whitelist` parameters.\n *\n * @memberof workbox.routing\n * @extends workbox.routing.Route\n */\nclass NavigationRoute extends Route {\n  /**\n   * If both `blacklist` and `whiltelist` are provided, the `blacklist` will\n   * take precedence and the request will not match this route.\n   *\n   * The regular expressions in `whitelist` and `blacklist`\n   * are matched against the concatenated\n   * [`pathname`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/pathname}\n   * and [`search`]{@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLHyperlinkElementUtils/search}\n   * portions of the requested URL.\n   *\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {Object} options\n   * @param {Array<RegExp>} [options.blacklist] If any of these patterns match,\n   * the route will not handle the request (even if a whitelist RegExp matches).\n   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n   * match the URL's pathname and search parameter, the route will handle the\n   * request (assuming the blacklist doesn't match).\n   */\n  constructor(handler, {whitelist = [/./], blacklist = []} = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isArrayOfClass(whitelist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.whitelist',\n      });\n      assert.isArrayOfClass(blacklist, RegExp, {\n        moduleName: 'workbox-routing',\n        className: 'NavigationRoute',\n        funcName: 'constructor',\n        paramName: 'options.blacklist',\n      });\n    }\n\n    super((...args) => this._match(...args), handler);\n\n    this._whitelist = whitelist;\n    this._blacklist = blacklist;\n  }\n\n  /**\n   * Routes match handler.\n   *\n   * @param {Object} input\n   * @param {FetchEvent} input.event\n   * @param {URL} input.url\n   * @return {boolean}\n   *\n   * @private\n   */\n  _match({event, url}) {\n    if (event.request.mode !== 'navigate') {\n      return false;\n    }\n\n    const pathnameAndSearch = url.pathname + url.search;\n\n    if (this._blacklist.some((regExp) => regExp.test(pathnameAndSearch))) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`The navigation route is not being used, since the ` +\n          `request URL matches both the whitelist and blacklist.`);\n      }\n      return false;\n    }\n\n    if (this._whitelist.some((regExp) => regExp.test(pathnameAndSearch))) {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(`The navigation route is being used.`);\n      }\n      return true;\n    } else {\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\n          `The navigation route is not being used, since the ` +\n          `URL being navigated to doesn't match the whitelist.`\n        );\n      }\n    }\n\n    return false;\n  }\n}\n\nexport {NavigationRoute};\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {NavigationRoute} from './NavigationRoute.mjs';\nimport {RegExpRoute} from './RegExpRoute.mjs';\nimport {Router} from './Router.mjs';\nimport {Route} from './Route.mjs';\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {cacheNames} from 'workbox-core/_private/cacheNames.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport './_version.mjs';\n\nif (process.env.NODE_ENV !== 'production') {\n  assert.isSwEnv('workbox-routing');\n}\n\n/**\n * @private\n */\nclass DefaultRouter extends Router {\n  /**\n   * Easily register a RegExp, string, or function with a caching\n   * strategy to the Router.\n   *\n   * This method will generate a Route for you if needed and\n   * call [Router.registerRoute()]{@link\n   * workbox.routing.Router#registerRoute}.\n   *\n   * @param {\n   * RegExp|\n   * string|\n   * workbox.routing.Route~matchCallback|\n   * workbox.routing.Route\n   * } capture\n   * If the capture param is a `Route`, all other arguments will be ignored.\n   * @param {workbox.routing.Route~handlerCallback} handler A callback\n   * function that returns a Promise resulting in a Response.\n   * @param {string} [method='GET'] The HTTP method to match the Route\n   * against.\n   * @return {workbox.routing.Route} The generated `Route`(Useful for\n   * unregistering).\n   *\n   * @alias workbox.routing.registerRoute\n   */\n  registerRoute(capture, handler, method = 'GET') {\n    let route;\n\n    if (typeof capture === 'string') {\n      const captureUrl = new URL(capture, location);\n\n      if (process.env.NODE_ENV !== 'production') {\n        if (!(capture.startsWith('/') || capture.startsWith('http'))) {\n          throw new WorkboxError('invalid-string', {\n            moduleName: 'workbox-routing',\n            className: 'DefaultRouter',\n            funcName: 'registerRoute',\n            paramName: 'capture',\n          });\n        }\n\n        // We want to check if Express-style wildcards are in the pathname only.\n        // TODO: Remove this log message in v4.\n        const valueToCheck = capture.startsWith('http') ?\n          captureUrl.pathname :\n          capture;\n        // See https://github.com/pillarjs/path-to-regexp#parameters\n        const wildcards = '[*:?+]';\n        if (valueToCheck.match(new RegExp(`${wildcards}`))) {\n          logger.debug(\n            `The '$capture' parameter contains an Express-style wildcard ` +\n            `character (${wildcards}). Strings are now always interpreted as ` +\n            `exact matches; use a RegExp for partial or wildcard matches.`\n          );\n        }\n      }\n\n      const matchCallback = ({url}) => {\n        if (process.env.NODE_ENV !== 'production') {\n          if ((url.pathname === captureUrl.pathname) &&\n              (url.origin !== captureUrl.origin)) {\n            logger.debug(\n              `${capture} only partially matches the cross-origin URL ` +\n              `${url}. This route will only handle cross-origin requests ` +\n              `if they match the entire URL.`\n            );\n          }\n        }\n\n        return url.href === captureUrl.href;\n      };\n\n      route = new Route(matchCallback, handler, method);\n    } else if (capture instanceof RegExp) {\n      route = new RegExpRoute(capture, handler, method);\n    } else if (typeof capture === 'function') {\n      route = new Route(capture, handler, method);\n    } else if (capture instanceof Route) {\n      route = capture;\n    } else {\n      throw new WorkboxError('unsupported-route-type', {\n        moduleName: 'workbox-routing',\n        className: 'DefaultRouter',\n        funcName: 'registerRoute',\n        paramName: 'capture',\n      });\n    }\n\n    super.registerRoute(route);\n    return route;\n  }\n\n  /**\n   * Register a route that will return a precached file for a navigation\n   * request. This is useful for the\n   * [application shell pattern]{@link https://developers.google.com/web/fundamentals/architecture/app-shell}.\n   *\n   * This method will generate a\n   * [NavigationRoute]{@link workbox.routing.NavigationRoute}\n   * and call\n   * [Router.registerRoute()]{@link workbox.routing.Router#registerRoute}\n   * .\n   *\n   * @param {string} cachedAssetUrl\n   * @param {Object} [options]\n   * @param {string} [options.cacheName] Cache name to store and retrieve\n   * requests. Defaults to precache cache name provided by\n   * [workbox-core.cacheNames]{@link workbox.core.cacheNames}.\n   * @param {Array<RegExp>} [options.blacklist=[]] If any of these patterns\n   * match, the route will not handle the request (even if a whitelist entry\n   * matches).\n   * @param {Array<RegExp>} [options.whitelist=[/./]] If any of these patterns\n   * match the URL's pathname and search parameter, the route will handle the\n   * request (assuming the blacklist doesn't match).\n   * @return {workbox.routing.NavigationRoute} Returns the generated\n   * Route.\n   *\n   * @alias workbox.routing.registerNavigationRoute\n   */\n  registerNavigationRoute(cachedAssetUrl, options = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cachedAssetUrl, 'string', {\n        moduleName: 'workbox-routing',\n        className: '[default export]',\n        funcName: 'registerNavigationRoute',\n        paramName: 'cachedAssetUrl',\n      });\n    }\n\n    const cacheName = cacheNames.getPrecacheName(options.cacheName);\n    const handler = () => caches.match(cachedAssetUrl, {cacheName});\n    const route = new NavigationRoute(handler, {\n      whitelist: options.whitelist,\n      blacklist: options.blacklist,\n    });\n    super.registerRoute(\n      route\n    );\n    return route;\n  }\n}\n\nconst router = new DefaultRouter();\n\n// By default, register a fetch event listener that will respond to a request\n// only if there's a matching route.\nself.addEventListener('fetch', (event) => {\n  const responsePromise = router.handleRequest(event);\n  if (responsePromise) {\n    event.respondWith(responsePromise);\n  }\n});\n\nexport default router;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\n\nimport * as publicAPI from './_public.mjs';\nimport defaultExport from './_default.mjs';\nimport './_version.mjs';\n\nconst finalExport = Object.assign(defaultExport, publicAPI);\n\nexport default finalExport;\n"],"names":["workbox","v","e","handler","handle","Route","match","method","normalizeHandler","RegExpRoute","regExp","url","result","exec","href","origin","location","index","slice","Router","_routes","Map","event","URL","request","protocol","startsWith","params","this","_findHandlerAndParams","_defaultHandler","responsePromise","err","Promise","reject","_catchHandler","catch","routes","get","route","matchResult","Array","isArray","length","undefined","constructor","Object","keys","has","set","push","WorkboxError","routeIndex","indexOf","splice","NavigationRoute","whitelist","blacklist","args","_match","_whitelist","_blacklist","mode","pathnameAndSearch","pathname","search","some","test","DefaultRouter","capture","captureUrl","RegExp","registerRoute","cachedAssetUrl","options","cacheName","cacheNames","getPrecacheName","caches","router","self","addEventListener","handleRequest","respondWith","assign","defaultExport","publicAPI"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0Z2F1bnQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4xL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtcm91dGluZy9fdmVyc2lvbi5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXJvdXRpbmcvdXRpbHMvbm9ybWFsaXplSGFuZGxlci5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXJvdXRpbmcvUm91dGUubWpzIiwiL1VzZXJzL21hdHRnYXVudC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjEvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1yb3V0aW5nL3V0aWxzL2NvbnN0YW50cy5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXJvdXRpbmcvUmVnRXhwUm91dGUubWpzIiwiL1VzZXJzL21hdHRnYXVudC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjEvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1yb3V0aW5nL1JvdXRlci5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXJvdXRpbmcvTmF2aWdhdGlvblJvdXRlLm1qcyIsIi9Vc2Vycy9tYXR0Z2F1bnQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4xL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtcm91dGluZy9fZGVmYXVsdC5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LXJvdXRpbmcvYnJvd3Nlci5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidHJ5e3NlbGYud29ya2JveC52Wyd3b3JrYm94OnJvdXRpbmc6My4wLjAtYWxwaGEuMSddPTE7fWNhdGNoKGUpe30gLy8gZXNsaW50LWRpc2FibGUtbGluZSIsIi8qXG4gQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQubWpzJztcbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufE9iamVjdH0gaGFuZGxlciBFaXRoZXIgYSBmdW5jdGlvbiwgb3IgYW4gb2JqZWN0IHdpdGggYVxuICogJ2hhbmRsZScgbWV0aG9kLlxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3Qgd2l0aCBhIGhhbmRsZSBtZXRob2QuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuZXhwb3J0IGRlZmF1bHQgKGhhbmRsZXIpID0+IHtcbiAgaWYgKGhhbmRsZXIgJiYgdHlwZW9mIGhhbmRsZXIgPT09ICdvYmplY3QnKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydC5oYXNNZXRob2QoaGFuZGxlciwgJ2hhbmRsZScsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgIHBhcmFtTmFtZTogJ2hhbmRsZXInLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBoYW5kbGVyO1xuICB9IGVsc2Uge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNUeXBlKGhhbmRsZXIsICdmdW5jdGlvbicsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlJyxcbiAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgIHBhcmFtTmFtZTogJ2hhbmRsZXInLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7aGFuZGxlOiBoYW5kbGVyfTtcbiAgfVxufTtcbiIsIi8qXG4gQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQubWpzJztcblxuaW1wb3J0IHtkZWZhdWx0TWV0aG9kLCB2YWxpZE1ldGhvZHN9IGZyb20gJy4vdXRpbHMvY29uc3RhbnRzLm1qcyc7XG5pbXBvcnQgbm9ybWFsaXplSGFuZGxlciBmcm9tICcuL3V0aWxzL25vcm1hbGl6ZUhhbmRsZXIubWpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5tanMnO1xuXG4vKipcbiAqIEEgYFJvdXRlYCBjb25zaXN0cyBvZiBhIHBhaXIgb2YgY2FsbGJhY2sgZnVuY3Rpb25zLCBcIm1hdGNoXCIgYW5kIFwiaGFuZGxlclwiLlxuICogVGhlIFwibWF0Y2hcIiBjYWxsYmFjayBkZXRlcm1pbmUgaWYgYSByb3V0ZSBzaG91bGQgYmUgdXNlZCB0byBcImhhbmRsZVwiIGFcbiAqIHJlcXVlc3QgYnkgcmV0dXJuaW5nIGEgbm9uLWZhbHN5IHZhbHVlIGlmIGl0IGNhbi4gVGhlIFwiaGFuZGxlclwiIGNhbGxiYWNrXG4gKiBpcyBjYWxsZWQgd2hlbiB0aGVyZSBpcyBhIG1hdGNoIGFuZCBzaG91bGQgcmV0dXJuIGEgUHJvbWlzZSB0aGF0IHJlc29sdmVzXG4gKiB0byBhIGBSZXNwb25zZWAuXG4gKlxuICogQG1lbWJlcm9mIHdvcmtib3gucm91dGluZ1xuICovXG5jbGFzcyBSb3V0ZSB7XG4gIC8qKlxuICAgKiBDb25zdHJ1Y3RvciBmb3IgUm91dGUgY2xhc3MuXG4gICAqXG4gICAqIEBwYXJhbSB7d29ya2JveC5yb3V0aW5nLlJvdXRlfm1hdGNoQ2FsbGJhY2t9IG1hdGNoXG4gICAqIEEgY2FsbGJhY2sgZnVuY3Rpb24gdGhhdCBkZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHJvdXRlIG1hdGNoZXMgYSBnaXZlblxuICAgKiBgZmV0Y2hgIGV2ZW50IGJ5IHJldHVybmluZyBhIG5vbi1mYWxzeSB2YWx1ZS5cbiAgICogQHBhcmFtIHt3b3JrYm94LnJvdXRpbmcuUm91dGV+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXNvbHZpbmcgdG8gYSBSZXNwb25zZS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IFttZXRob2Q9J0dFVCddIFRoZSBIVFRQIG1ldGhvZCB0byBtYXRjaCB0aGUgUm91dGVcbiAgICogYWdhaW5zdC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKG1hdGNoLCBoYW5kbGVyLCBtZXRob2QpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0LmlzVHlwZShtYXRjaCwgJ2Z1bmN0aW9uJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnUm91dGUnLFxuICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgcGFyYW1OYW1lOiAnbWF0Y2gnLFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChtZXRob2QpIHtcbiAgICAgICAgYXNzZXJ0LmlzT25lT2YobWV0aG9kLCB2YWxpZE1ldGhvZHMsIHtwYXJhbU5hbWU6ICdtZXRob2QnfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gVGhlc2UgdmFsdWVzIGFyZSByZWZlcmVuY2VkIGRpcmVjdGx5IGJ5IFJvdXRlciBzbyBjYW5ub3QgYmVcbiAgICAvLyBhbHRlcmVkIGJ5IG1pbmlmaWZpY2F0aW9uLlxuICAgIHRoaXMuaGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gICAgdGhpcy5tYXRjaCA9IG1hdGNoO1xuICAgIHRoaXMubWV0aG9kID0gbWV0aG9kIHx8IGRlZmF1bHRNZXRob2Q7XG4gIH1cbn1cblxuZXhwb3J0IHtSb3V0ZX07XG4iLCIvKlxuIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCAnLi4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBIVFRQIG1ldGhvZCwgJ0dFVCcsIHVzZWQgd2hlbiB0aGVyZSdzIG5vIHNwZWNpZmljIG1ldGhvZFxuICogY29uZmlndXJlZCBmb3IgYSByb3V0ZS5cbiAqXG4gKiBAdHlwZSB7c3RyaW5nfVxuICpcbiAqIEBwcml2YXRlXG4gKi9cbmV4cG9ydCBjb25zdCBkZWZhdWx0TWV0aG9kID0gJ0dFVCc7XG5cbi8qKlxuICogVGhlIGxpc3Qgb2YgdmFsaWQgSFRUUCBtZXRob2RzIGFzc29jaWF0ZWQgd2l0aCByZXF1ZXN0cyB0aGF0IGNvdWxkIGJlIHJvdXRlZC5cbiAqXG4gKiBAdHlwZSB7QXJyYXk8c3RyaW5nPn1cbiAqXG4gKiBAcHJpdmF0ZVxuICovXG5leHBvcnQgY29uc3QgdmFsaWRNZXRob2RzID0gW1xuICAnREVMRVRFJyxcbiAgJ0dFVCcsXG4gICdIRUFEJyxcbiAgJ1BPU1QnLFxuICAnUFVUJyxcbl07XG4iLCIvKlxuIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0Lm1qcyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5tanMnO1xuaW1wb3J0IHtSb3V0ZX0gZnJvbSAnLi9Sb3V0ZS5tanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogUmVnRXhwUm91dGUgbWFrZXMgaXQgZWFzeSB0byBjcmVhdGUgYSByZWd1bGFyIGV4cHJlc3Npb24gYmFzZWRcbiAqIFtSb3V0ZV17QGxpbmsgd29ya2JveC5yb3V0aW5nLlJvdXRlfS5cbiAqXG4gKiBGb3Igc2FtZS1vcmlnaW4gcmVxdWVzdHMgdGhlIFJlZ0V4cCBvbmx5IG5lZWRzIHRvIG1hdGNoIHBhcnQgb2YgdGhlIFVSTC4gRm9yXG4gKiByZXF1ZXN0cyBhZ2FpbnN0IHRoaXJkLXBhcnR5IHNlcnZlcnMsIHlvdSBtdXN0IGRlZmluZSBhIFJlZ0V4cCB0aGF0IG1hdGNoZXNcbiAqIHRoZSBzdGFydCBvZiB0aGUgVVJMLlxuICpcbiAqIFtTZWUgdGhlIG1vZHVsZSBkb2NzIGZvciBpbmZvLl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL3Rvb2xzL3dvcmtib3gvdjMvbW9kdWxlcy93b3JrYm94LXJvdXRpbmd9XG4gKlxuICogQG1lbWJlcm9mIHdvcmtib3gucm91dGluZ1xuICogQGV4dGVuZHMgd29ya2JveC5yb3V0aW5nLlJvdXRlXG4gKi9cbmNsYXNzIFJlZ0V4cFJvdXRlIGV4dGVuZHMgUm91dGUge1xuICAvKipcbiAgICogSWYgdGhlIHJlZ3VsYXJkIGV4cHJlc3Npb24gY29udGFpbnNcbiAgICogW2NhcHR1cmUgZ3JvdXBzXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9SZWdFeHAjZ3JvdXBpbmctYmFjay1yZWZlcmVuY2VzfSxcbiAgICogdGggZWNhcHR1cmVkIHZhbHVlcyB3aWxsIGJlIHBhc3NlZCB0byB0aGVcbiAgICogW2hhbmRsZXInc117QGxpbmsgd29ya2JveC5yb3V0aW5nLlJvdXRlfmhhbmRsZXJDYWxsYmFja30gYHBhcmFtc2BcbiAgICogYXJndW1lbnQuXG4gICAqXG4gICAqIEBwYXJhbSB7UmVnRXhwfSByZWdFeHAgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiB0byBtYXRjaCBhZ2FpbnN0IFVSTHMuXG4gICAqIEBwYXJhbSB7d29ya2JveC5yb3V0aW5nLlJvdXRlfmhhbmRsZXJDYWxsYmFja30gaGFuZGxlciBBIGNhbGxiYWNrXG4gICAqIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIFByb21pc2UgcmVzdWx0aW5nIGluIGEgUmVzcG9uc2UuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbWV0aG9kPSdHRVQnXSBUaGUgSFRUUCBtZXRob2QgdG8gbWF0Y2ggdGhlIFJvdXRlXG4gICAqIGFnYWluc3QuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihyZWdFeHAsIGhhbmRsZXIsIG1ldGhvZCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNJbnN0YW5jZShyZWdFeHAsIFJlZ0V4cCwge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnUmVnRXhwUm91dGUnLFxuICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgcGFyYW1OYW1lOiAncGF0dGVybicsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBtYXRjaCA9ICh7dXJsfSkgPT4ge1xuICAgICAgY29uc3QgcmVzdWx0ID0gcmVnRXhwLmV4ZWModXJsLmhyZWYpO1xuXG4gICAgICAvLyBSZXR1cm4gbnVsbCBpbW1lZGlhdGVseSBpZiB0aGVyZSdzIG5vIG1hdGNoLlxuICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlcXVpcmUgdGhhdCB0aGUgbWF0Y2ggc3RhcnQgYXQgdGhlIGZpcnN0IGNoYXJhY3RlciBpbiB0aGUgVVJMIHN0cmluZ1xuICAgICAgLy8gaWYgaXQncyBhIGNyb3NzLW9yaWdpbiByZXF1ZXN0LlxuICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9Hb29nbGVDaHJvbWUvd29ya2JveC9pc3N1ZXMvMjgxIGZvciB0aGUgY29udGV4dFxuICAgICAgLy8gYmVoaW5kIHRoaXMgYmVoYXZpb3IuXG4gICAgICBpZiAoKHVybC5vcmlnaW4gIT09IGxvY2F0aW9uLm9yaWdpbikgJiYgKHJlc3VsdC5pbmRleCAhPT0gMCkpIHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgVGhlIHJlZ3VsYXIgZXhwcmVzc2lvbiAnJHtyZWdFeHB9JyBvbmx5IHBhcnRpYWxseSBtYXRjaGVkIGAgK1xuICAgICAgICAgICAgYGFnYWluc3QgdGhlIGNyb3NzLW9yaWdpbiBVUkwgJyR7dXJsfScuIFJlZ0V4cFJvdXRlJ3Mgd2lsbCBvbmx5IGAgK1xuICAgICAgICAgICAgYGhhbmRsZSBjcm9zcy1vcmlnaW4gcmVxdWVzdHMgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgcm91dGUgbWF0Y2hlcywgYnV0IHRoZXJlIGFyZW4ndCBhbnkgY2FwdHVyZSBncm91cHMgZGVmaW5lZCwgdGhlblxuICAgICAgLy8gdGhpcyB3aWxsIHJldHVybiBbXSwgd2hpY2ggaXMgdHJ1dGh5IGFuZCB0aGVyZWZvcmUgc3VmZmljaWVudCB0b1xuICAgICAgLy8gaW5kaWNhdGUgYSBtYXRjaC5cbiAgICAgIC8vIElmIHRoZXJlIGFyZSBjYXB0dXJlIGdyb3VwcywgdGhlbiBpdCB3aWxsIHJldHVybiB0aGVpciB2YWx1ZXMuXG4gICAgICByZXR1cm4gcmVzdWx0LnNsaWNlKDEpO1xuICAgIH07XG5cbiAgICBzdXBlcihtYXRjaCwgaGFuZGxlciwgbWV0aG9kKTtcbiAgfVxufVxuXG5leHBvcnQge1JlZ0V4cFJvdXRlfTtcbiIsIi8qXG4gQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQubWpzJztcbmltcG9ydCB7bG9nZ2VyfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvbG9nZ2VyLm1qcyc7XG5pbXBvcnQge1dvcmtib3hFcnJvcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5tanMnO1xuaW1wb3J0IHtnZXRGcmllbmRseVVSTH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2dldEZyaWVuZGx5VVJMLm1qcyc7XG5cbmltcG9ydCBub3JtYWxpemVIYW5kbGVyIGZyb20gJy4vdXRpbHMvbm9ybWFsaXplSGFuZGxlci5tanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogVGhlIFJvdXRlciBjYW4gYmUgdXNlZCB0byBwcm9jZXNzIGEgRmV0Y2hFdmVudCB0aHJvdWdoIG9uZSBvciBtb3JlXG4gKiBbUm91dGVzXXtAbGluayB3b3JrYm94LnJvdXRpbmcuUm91dGV9IHJlc3BvbmRpbmcgIHdpdGggYSBSZXF1ZXN0IGlmXG4gKiBhIG1hdGNoaW5nIHJvdXRlIGV4aXN0cy5cbiAqXG4gKiBJZiBubyByb3V0ZSBtYXRjaGVzIGEgZ2l2ZW4gYSByZXF1ZXN0LCB0aGUgUm91dGVyIHdpbGwgdXNlIGEgXCJkZWZhdWx0XCJcbiAqIGhhbmRsZXIgaWYgb25lIGlzIGRlZmluZWQuXG4gKlxuICogU2hvdWxkIHRoZSBtYXRjaGluZyBSb3V0ZSB0aHJvdyBhbiBlcnJvciwgdGhlIFJvdXRlciB3aWxsIHVzZSBhIFwiY2F0Y2hcIlxuICogaGFuZGxlciBpZiBvbmUgaXMgZGVmaW5lZCB0byBncmFjZWZ1bGx5IGRlYWwgd2l0aCBpc3N1ZXMgYW5kIHJlc3BvbmQgd2l0aCBhXG4gKiBSZXF1ZXN0LlxuICpcbiAqIElmIGEgcmVxdWVzdCBtYXRjaGVzIG11bHRpcGxlIHJvdXRlcywgdGhlICoqZWFybGllc3QqKiByZWdpc3RlcmVkIHJvdXRlIHdpbGxcbiAqIGJlIHVzZWQgdG8gcmVzcG9uZCB0byB0aGUgcmVxdWVzdC5cbiAqXG4gKiBAbWVtYmVyb2Ygd29ya2JveC5yb3V0aW5nXG4gKi9cbmNsYXNzIFJvdXRlciB7XG4gIC8qKlxuICAgKiBJbml0aWFsaXplcyBhIG5ldyBSb3V0ZXIuXG4gICAqL1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICAvLyBfcm91dGVzIHdpbGwgY29udGFpbiBhIG1hcHBpbmcgb2YgSFRUUCBtZXRob2QgbmFtZSAoJ0dFVCcsIGV0Yy4pIHRvIGFuXG4gICAgLy8gYXJyYXkgb2YgYWxsIHRoZSBjb3JyZXNwb25kaW5nIFJvdXRlIGluc3RhbmNlcyB0aGF0IGFyZSByZWdpc3RlcmVkLlxuICAgIHRoaXMuX3JvdXRlcyA9IG5ldyBNYXAoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBcHBseSB0aGUgcm91dGluZyBydWxlcyB0byBhIEZldGNoRXZlbnQgb2JqZWN0IHRvIGdldCBhIFJlc3BvbnNlIGZyb20gYW5cbiAgICogYXBwcm9wcmlhdGUgUm91dGUncyBoYW5kbGVyLlxuICAgKlxuICAgKiBAcGFyYW0ge0ZldGNoRXZlbnR9IGV2ZW50IFRoZSBldmVudCBmcm9tIGEgc2VydmljZSB3b3JrZXIncyAnZmV0Y2gnIGV2ZW50XG4gICAqIGxpc3RlbmVyLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPFJlc3BvbnNlPnx1bmRlZmluZWR9IEEgcHJvbWlzZSBpcyByZXR1cm5lZCBpZiBhXG4gICAqIHJlZ2lzdGVyZWQgcm91dGUgY2FuIGhhbmRsZSB0aGUgRmV0Y2hFdmVudCdzIHJlcXVlc3QuIElmIHRoZXJlIGlzIG5vXG4gICAqIG1hdGNoaW5nIHJvdXRlIGFuZCB0aGVyZSdzIG5vIGBkZWZhdWx0SGFuZGxlcmAsIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgKi9cbiAgaGFuZGxlUmVxdWVzdChldmVudCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNJbnN0YW5jZShldmVudCwgRmV0Y2hFdmVudCwge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgZnVuY05hbWU6ICdoYW5kbGVSZXF1ZXN0JyxcbiAgICAgICAgcGFyYW1OYW1lOiAnZXZlbnQnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgY29uc3QgdXJsID0gbmV3IFVSTChldmVudC5yZXF1ZXN0LnVybCk7XG4gICAgaWYgKCF1cmwucHJvdG9jb2wuc3RhcnRzV2l0aCgnaHR0cCcpKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgYFdvcmtib3ggUm91dGVyIG9ubHkgc3VwcG9ydHMgVVJMcyB0aGF0IHN0YXJ0IHdpdGggJ2h0dHAnLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGxldCByb3V0ZSA9IG51bGw7XG4gICAgbGV0IGhhbmRsZXIgPSBudWxsO1xuICAgIGxldCBwYXJhbXMgPSBudWxsO1xuICAgIGxldCBkZWJ1Z01lc3NhZ2VzID0gW107XG5cbiAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9maW5kSGFuZGxlckFuZFBhcmFtcyhldmVudCwgdXJsKTtcbiAgICBoYW5kbGVyID0gcmVzdWx0LmhhbmRsZXI7XG4gICAgcGFyYW1zID0gcmVzdWx0LnBhcmFtcztcbiAgICByb3V0ZSA9IHJlc3VsdC5yb3V0ZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKGhhbmRsZXIpIHtcbiAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICBgRm91bmQgYSByb3V0ZSB0byBoYW5kbGUgdGhpcyByZXF1ZXN0OmAsIHJvdXRlLFxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgICAgZGVidWdNZXNzYWdlcy5wdXNoKFtcbiAgICAgICAgICAgIGBQYXNzaW5nIHRoZSBmb2xsb3dpbmcgcGFyYW1zIHRvIHRoZSByb3V0ZSdzIGhhbmRsZXI6YCwgcGFyYW1zLFxuICAgICAgICAgIF0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIGhhbmRsZXIgYmVjYXVzZSB0aGVyZSB3YXMgbm8gbWF0Y2hpbmcgcm91dGUsIHRoZW5cbiAgICAvLyBmYWxsIGJhY2sgdG8gZGVmYXVsdEhhbmRsZXIgaWYgdGhhdCdzIGRlZmluZWQuXG4gICAgaWYgKCFoYW5kbGVyICYmIHRoaXMuX2RlZmF1bHRIYW5kbGVyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICBkZWJ1Z01lc3NhZ2VzLnB1c2goYEZhaWxlZCB0byBmaW5kIGEgbWF0Y2hpbmcgcm91dGUuIEZhbGxpbmcgYCArXG4gICAgICAgICAgYGJhY2sgdG8gdGhlIGRlZmF1bHQgaGFuZGxlci5gKTtcblxuICAgICAgICAvLyBUaGlzIGlzIHVzZWQgZm9yIGRlYnVnZ2luZyBpbiBsb2dzIGluIHRoZSBjYXNlIG9mIGFuIGVycm9yLlxuICAgICAgICByb3V0ZSA9ICdbRGVmYXVsdCBIYW5kbGVyXSc7XG4gICAgICB9XG4gICAgICBoYW5kbGVyID0gdGhpcy5fZGVmYXVsdEhhbmRsZXI7XG4gICAgfVxuXG4gICAgaWYgKCFoYW5kbGVyKSB7XG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAvLyBObyBoYW5kbGVyIHNvIFdvcmtib3ggd2lsbCBkbyBub3RoaW5nLiBJZiBsb2dzIGlzIHNldCBvZiBkZWJ1Z1xuICAgICAgICAvLyBpLmUuIHZlcmJvc2UsIHdlIHNob3VsZCBwcmludCBvdXQgdGhpcyBpbmZvcm1hdGlvbi5cbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBObyByb3V0ZSBmb3VuZCBmb3I6ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gV2UgaGF2ZSBhIGhhbmRsZXIsIG1lYW5pbmcgV29ya2JveCBpcyBnb2luZyB0byBoYW5kbGUgdGhlIHJvdXRlLlxuICAgICAgLy8gcHJpbnQgdGhlIHJvdXRpbmcgZGV0YWlscyB0byB0aGUgY29uc29sZS5cbiAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgUm91dGVyIGlzIHJlc3BvbmRpbmcgdG86ICR7Z2V0RnJpZW5kbHlVUkwodXJsKX1gKTtcbiAgICAgIGRlYnVnTWVzc2FnZXMuZm9yRWFjaCgobXNnKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KG1zZykpIHtcbiAgICAgICAgICBsb2dnZXIubG9nKC4uLm1zZyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbG9nZ2VyLmxvZyhtc2cpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gVGhlIFJlcXVlc3QgYW5kIFJlc3BvbnNlIG9iamVjdHMgY29udGFpbnMgYSBncmVhdCBkZWFsIG9mIGluZm9ybWF0aW9uLFxuICAgICAgLy8gaGlkZSBpdCB1bmRlciBhIGdyb3VwIGluIGNhc2UgZGV2ZWxvcGVycyB3YW50IHRvIHNlZSBpdC5cbiAgICAgIGxvZ2dlci5ncm91cENvbGxhcHNlZChgVmlldyByZXF1ZXN0IGRldGFpbHMgaGVyZS5gKTtcbiAgICAgIGxvZ2dlci51bnByZWZpeGVkLmxvZyhldmVudC5yZXF1ZXN0KTtcbiAgICAgIGxvZ2dlci5ncm91cEVuZCgpO1xuXG4gICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICB9XG5cbiAgICAvLyBXcmFwIGluIHRyeSBhbmQgY2F0Y2ggaW4gY2FzZSB0aGUgaGFuZGxlIG1ldGhvZCB0aHJvd3MgYSBzeW5jaHJvbm91c1xuICAgIC8vIGVycm9yLiBJdCBzaG91bGQgc3RpbGwgY2FsbGJhY2sgdG8gdGhlIGNhdGNoIGhhbmRsZXIuXG4gICAgbGV0IHJlc3BvbnNlUHJvbWlzZTtcbiAgICB0cnkge1xuICAgICAgcmVzcG9uc2VQcm9taXNlID0gaGFuZGxlci5oYW5kbGUoe3VybCwgZXZlbnQsIHBhcmFtc30pO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgcmVzcG9uc2VQcm9taXNlID0gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB9XG5cbiAgICBpZiAocmVzcG9uc2VQcm9taXNlICYmIHRoaXMuX2NhdGNoSGFuZGxlcikge1xuICAgICAgcmVzcG9uc2VQcm9taXNlID0gcmVzcG9uc2VQcm9taXNlLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICAvLyBTdGlsbCBpbmNsdWRlIFVSTCBoZXJlIGFzIGl0IHdpbGwgYmUgYXN5bmMgZnJvbSB0aGUgY29uc29sZSBncm91cFxuICAgICAgICAgIC8vIGFuZCBtYXkgbm90IG1ha2Ugc2Vuc2Ugd2l0aG91dCB0aGUgVVJMXG4gICAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKGBFcnJvciB0aHJvd24gd2hlbiByZXNwb25kaW5nIHRvOiBgICtcbiAgICAgICAgICAgIGAgJHtnZXRGcmllbmRseVVSTCh1cmwpfS4gRmFsbGluZyBiYWNrIHRvIENhdGNoIEhhbmRsZXIuYCk7XG4gICAgICAgICAgbG9nZ2VyLnVucHJlZml4ZWQuZXJyb3IoYEVycm9yIHRocm93biBieTpgLCByb3V0ZSk7XG4gICAgICAgICAgbG9nZ2VyLnVucHJlZml4ZWQuZXJyb3IoZXJyKTtcbiAgICAgICAgICBsb2dnZXIuZ3JvdXBFbmQoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fY2F0Y2hIYW5kbGVyLmhhbmRsZSh7dXJsLCBldmVudCwgZXJyfSk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzcG9uc2VQcm9taXNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyB0aGUgaW5jb21pbmcgYGV2ZW50LnJlcXVlc3RgIGFnYWluc3QgdGhlIHJlZ2lzdGVyZWQgcm91dGVzLCBhbmQgaWZcbiAgICogdGhlcmUncyBhIG1hdGNoLCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIGhhbmRsZXIgYWxvbmcgd2l0aCBhbnkgcGFyYW1zXG4gICAqIGdlbmVyYXRlZCBieSB0aGUgbWF0Y2guXG4gICAqXG4gICAqIEBwYXJhbSB7RmV0Y2hFdmVudH0gZXZlbnRcbiAgICogQHBhcmFtIHtVUkx9IHVybFxuICAgKiBAcmV0dXJuIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IHdpdGggYGhhbmRsZXJgIGFuZCBgcGFyYW1zYCBwcm9wZXJ0aWVzLlxuICAgKiBUaGV5IGFyZSBwb3B1bGF0ZWQgaWYgYSBtYXRjaGluZyByb3V0ZSB3YXMgZm91bmQgb3IgYHVuZGVmaW5lZGAgb3RoZXJ3aXNlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2ZpbmRIYW5kbGVyQW5kUGFyYW1zKGV2ZW50LCB1cmwpIHtcbiAgICBjb25zdCByb3V0ZXMgPSB0aGlzLl9yb3V0ZXMuZ2V0KGV2ZW50LnJlcXVlc3QubWV0aG9kKSB8fCBbXTtcbiAgICBmb3IgKGNvbnN0IHJvdXRlIG9mIHJvdXRlcykge1xuICAgICAgbGV0IG1hdGNoUmVzdWx0ID0gcm91dGUubWF0Y2goe3VybCwgZXZlbnR9KTtcbiAgICAgIGlmIChtYXRjaFJlc3VsdCkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShtYXRjaFJlc3VsdCkgJiYgbWF0Y2hSZXN1bHQubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgLy8gSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVtcHR5IGFycmF5IGluIGFzIHBhcmFtcywgdXNlIHVuZGVmaW5lZC5cbiAgICAgICAgICBtYXRjaFJlc3VsdCA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSBlbHNlIGlmICgobWF0Y2hSZXN1bHQuY29uc3RydWN0b3IgPT09IE9iamVjdCAmJlxuICAgICAgICAgIE9iamVjdC5rZXlzKG1hdGNoUmVzdWx0KS5sZW5ndGggPT09IDApIHx8IG1hdGNoUmVzdWx0ID09PSB0cnVlKSB7XG4gICAgICAgICAgLy8gSW5zdGVhZCBvZiBwYXNzaW5nIGFuIGVtcHR5IG9iamVjdCBpbiBhcyBwYXJhbXMsIHVzZSB1bmRlZmluZWQuXG4gICAgICAgICAgbWF0Y2hSZXN1bHQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBCcmVhayBvdXQgb2YgdGhlIGxvb3AgYW5kIHJldHVybiB0aGUgYXBwcm9wcmlhdGUgdmFsdWVzIGFzIHNvb24gYXNcbiAgICAgICAgLy8gd2UgaGF2ZSBhIG1hdGNoLlxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvdXRlLFxuICAgICAgICAgIHBhcmFtczogbWF0Y2hSZXN1bHQsXG4gICAgICAgICAgaGFuZGxlcjogcm91dGUuaGFuZGxlcixcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBkaWRuJ3QgaGF2ZSBhIG1hdGNoLCB0aGVuIHJldHVybiB1bmRlZmluZWQgdmFsdWVzLlxuICAgIHJldHVybiB7aGFuZGxlcjogdW5kZWZpbmVkLCBwYXJhbXM6IHVuZGVmaW5lZH07XG4gIH1cblxuICAvKipcbiAgICogRGVmaW5lIGEgZGVmYXVsdCBgaGFuZGxlcmAgdGhhdCdzIGNhbGxlZCB3aGVuIG5vIHJvdXRlcyBleHBsaWNpdGx5XG4gICAqIG1hdGNoIHRoZSBpbmNvbWluZyByZXF1ZXN0LlxuICAgKlxuICAgKiBXaXRob3V0IGEgZGVmYXVsdCBoYW5kbGVyLCB1bm1hdGNoZWQgcmVxdWVzdHMgd2lsbCBnbyBhZ2FpbnN0IHRoZVxuICAgKiBuZXR3b3JrIGFzIGlmIHRoZXJlIHdlcmUgbm8gc2VydmljZSB3b3JrZXIgcHJlc2VudC5cbiAgICpcbiAgICogQHBhcmFtIHt3b3JrYm94LnJvdXRpbmcuUm91dGV+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICovXG4gIHNldERlZmF1bHRIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9kZWZhdWx0SGFuZGxlciA9IG5vcm1hbGl6ZUhhbmRsZXIoaGFuZGxlcik7XG4gIH1cblxuICAvKipcbiAgICogSWYgYSBSb3V0ZSB0aHJvd3MgYW4gZXJyb3Igd2hpbGUgaGFuZGxpbmcgYSByZXF1ZXN0LCB0aGlzIGBoYW5kbGVyYFxuICAgKiB3aWxsIGJlIGNhbGxlZCBhbmQgZ2l2ZW4gYSBjaGFuY2UgdG8gcHJvdmlkZSBhIHJlc3BvbnNlLlxuICAgKlxuICAgKiBAcGFyYW0ge3dvcmtib3gucm91dGluZy5Sb3V0ZX5oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgKi9cbiAgc2V0Q2F0Y2hIYW5kbGVyKGhhbmRsZXIpIHtcbiAgICB0aGlzLl9jYXRjaEhhbmRsZXIgPSBub3JtYWxpemVIYW5kbGVyKGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhIHJvdXRlIHdpdGggdGhlIHJvdXRlci5cbiAgICpcbiAgICogQHBhcmFtIHt3b3JrYm94LnJvdXRpbmcuUm91dGV9IHJvdXRlIFRoZSByb3V0ZSB0byByZWdpc3Rlci5cbiAgICovXG4gIHJlZ2lzdGVyUm91dGUocm91dGUpIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0LmlzVHlwZShyb3V0ZSwgJ29iamVjdCcsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlJyxcbiAgICAgIH0pO1xuXG4gICAgICBhc3NlcnQuaGFzTWV0aG9kKHJvdXRlLCAnbWF0Y2gnLCB7XG4gICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICBjbGFzc05hbWU6ICdSb3V0ZXInLFxuICAgICAgICBmdW5jTmFtZTogJ3JlZ2lzdGVyUm91dGUnLFxuICAgICAgICBwYXJhbU5hbWU6ICdyb3V0ZScsXG4gICAgICB9KTtcblxuICAgICAgYXNzZXJ0LmlzVHlwZShyb3V0ZS5oYW5kbGVyLCAnb2JqZWN0Jywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgcGFyYW1OYW1lOiAncm91dGUnLFxuICAgICAgfSk7XG5cbiAgICAgIGFzc2VydC5oYXNNZXRob2Qocm91dGUuaGFuZGxlciwgJ2hhbmRsZScsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgIGNsYXNzTmFtZTogJ1JvdXRlcicsXG4gICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgIHBhcmFtTmFtZTogJ3JvdXRlLmhhbmRsZXInLFxuICAgICAgfSk7XG5cbiAgICAgIGFzc2VydC5pc1R5cGUocm91dGUubWV0aG9kLCAnc3RyaW5nJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnUm91dGVyJyxcbiAgICAgICAgZnVuY05hbWU6ICdyZWdpc3RlclJvdXRlJyxcbiAgICAgICAgcGFyYW1OYW1lOiAncm91dGUubWV0aG9kJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICB0aGlzLl9yb3V0ZXMuc2V0KHJvdXRlLm1ldGhvZCwgW10pO1xuICAgIH1cblxuICAgIC8vIEdpdmUgcHJlY2VkZW5jZSB0byBhbGwgb2YgdGhlIGVhcmxpZXIgcm91dGVzIGJ5IGFkZGluZyB0aGlzIGFkZGl0aW9uYWxcbiAgICAvLyByb3V0ZSB0byB0aGUgZW5kIG9mIHRoZSBhcnJheS5cbiAgICB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkucHVzaChyb3V0ZSk7XG4gIH1cblxuICAvKipcbiAgICogVW5yZWdpc3RlcnMgYSByb3V0ZSB3aXRoIHRoZSByb3V0ZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7d29ya2JveC5yb3V0aW5nLlJvdXRlfSByb3V0ZSBUaGUgcm91dGUgdG8gdW5yZWdpc3Rlci5cbiAgICovXG4gIHVucmVnaXN0ZXJSb3V0ZShyb3V0ZSkge1xuICAgIGlmICghdGhpcy5fcm91dGVzLmhhcyhyb3V0ZS5tZXRob2QpKSB7XG4gICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKFxuICAgICAgICAndW5yZWdpc3Rlci1yb3V0ZS1idXQtbm90LWZvdW5kLXdpdGgtbWV0aG9kJywge1xuICAgICAgICAgIG1ldGhvZDogcm91dGUubWV0aG9kLFxuICAgICAgICB9XG4gICAgICApO1xuICAgIH1cblxuICAgIGNvbnN0IHJvdXRlSW5kZXggPSB0aGlzLl9yb3V0ZXMuZ2V0KHJvdXRlLm1ldGhvZCkuaW5kZXhPZihyb3V0ZSk7XG4gICAgaWYgKHJvdXRlSW5kZXggPiAtMSkge1xuICAgICAgdGhpcy5fcm91dGVzLmdldChyb3V0ZS5tZXRob2QpLnNwbGljZShyb3V0ZUluZGV4LCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcigndW5yZWdpc3Rlci1yb3V0ZS1yb3V0ZS1ub3QtcmVnaXN0ZXJlZCcpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQge1JvdXRlcn07XG4iLCIvKlxuIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2Fzc2VydC5tanMnO1xuaW1wb3J0IHtsb2dnZXJ9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9sb2dnZXIubWpzJztcbmltcG9ydCB7Um91dGV9IGZyb20gJy4vUm91dGUubWpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5tanMnO1xuXG4vKipcbiAqIE5hdmlnYXRpb25Sb3V0ZSBtYWtlcyBpdCBlYXN5IHRvIGNyZWF0ZSBhIFtSb3V0ZV17QGxpbmtcbiAqIHdvcmtib3gucm91dGluZy5Sb3V0ZX0gdGhhdCBtYXRjaGVzIGZvciBicm93c2VyXG4gKiBbbmF2aWdhdGlvbiByZXF1ZXN0c117QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9wcmltZXJzL3NlcnZpY2Utd29ya2Vycy9oaWdoLXBlcmZvcm1hbmNlLWxvYWRpbmcjZmlyc3Rfd2hhdF9hcmVfbmF2aWdhdGlvbl9yZXF1ZXN0c30uXG4gKlxuICogSXQgd2lsbCBvbmx5IG1hdGNoIGluY29taW5nIFJlcXVlc3RzIHdob3NlXG4gKiBbYG1vZGVgXXtAbGluayBodHRwczovL2ZldGNoLnNwZWMud2hhdHdnLm9yZy8jY29uY2VwdC1yZXF1ZXN0LW1vZGV9XG4gKiBpcyBzZXQgdG8gYG5hdmlnYXRlYC5cbiAqXG4gKiBZb3UgY2FuIG9wdGlvbmFsbHkgb25seSBhcHBseSB0aGlzIHJvdXRlIHRvIGEgc3Vic2V0IG9mIG5hdmlnYXRpb24gcmVxdWVzdHNcbiAqIGJ5IHVzaW5nIG9uZSBvciBib3RoIG9mIHRoZSBgYmxhY2tsaXN0YCBhbmQgYHdoaXRlbGlzdGAgcGFyYW1ldGVycy5cbiAqXG4gKiBAbWVtYmVyb2Ygd29ya2JveC5yb3V0aW5nXG4gKiBAZXh0ZW5kcyB3b3JrYm94LnJvdXRpbmcuUm91dGVcbiAqL1xuY2xhc3MgTmF2aWdhdGlvblJvdXRlIGV4dGVuZHMgUm91dGUge1xuICAvKipcbiAgICogSWYgYm90aCBgYmxhY2tsaXN0YCBhbmQgYHdoaWx0ZWxpc3RgIGFyZSBwcm92aWRlZCwgdGhlIGBibGFja2xpc3RgIHdpbGxcbiAgICogdGFrZSBwcmVjZWRlbmNlIGFuZCB0aGUgcmVxdWVzdCB3aWxsIG5vdCBtYXRjaCB0aGlzIHJvdXRlLlxuICAgKlxuICAgKiBUaGUgcmVndWxhciBleHByZXNzaW9ucyBpbiBgd2hpdGVsaXN0YCBhbmQgYGJsYWNrbGlzdGBcbiAgICogYXJlIG1hdGNoZWQgYWdhaW5zdCB0aGUgY29uY2F0ZW5hdGVkXG4gICAqIFtgcGF0aG5hbWVgXXtAbGluayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvSFRNTEh5cGVybGlua0VsZW1lbnRVdGlscy9wYXRobmFtZX1cbiAgICogYW5kIFtgc2VhcmNoYF17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxIeXBlcmxpbmtFbGVtZW50VXRpbHMvc2VhcmNofVxuICAgKiBwb3J0aW9ucyBvZiB0aGUgcmVxdWVzdGVkIFVSTC5cbiAgICpcbiAgICogQHBhcmFtIHt3b3JrYm94LnJvdXRpbmcuUm91dGV+aGFuZGxlckNhbGxiYWNrfSBoYW5kbGVyIEEgY2FsbGJhY2tcbiAgICogZnVuY3Rpb24gdGhhdCByZXR1cm5zIGEgUHJvbWlzZSByZXN1bHRpbmcgaW4gYSBSZXNwb25zZS5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheTxSZWdFeHA+fSBbb3B0aW9ucy5ibGFja2xpc3RdIElmIGFueSBvZiB0aGVzZSBwYXR0ZXJucyBtYXRjaCxcbiAgICogdGhlIHJvdXRlIHdpbGwgbm90IGhhbmRsZSB0aGUgcmVxdWVzdCAoZXZlbiBpZiBhIHdoaXRlbGlzdCBSZWdFeHAgbWF0Y2hlcykuXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gW29wdGlvbnMud2hpdGVsaXN0PVsvLi9dXSBJZiBhbnkgb2YgdGhlc2UgcGF0dGVybnNcbiAgICogbWF0Y2ggdGhlIFVSTCdzIHBhdGhuYW1lIGFuZCBzZWFyY2ggcGFyYW1ldGVyLCB0aGUgcm91dGUgd2lsbCBoYW5kbGUgdGhlXG4gICAqIHJlcXVlc3QgKGFzc3VtaW5nIHRoZSBibGFja2xpc3QgZG9lc24ndCBtYXRjaCkuXG4gICAqL1xuICBjb25zdHJ1Y3RvcihoYW5kbGVyLCB7d2hpdGVsaXN0ID0gWy8uL10sIGJsYWNrbGlzdCA9IFtdfSA9IHt9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydC5pc0FycmF5T2ZDbGFzcyh3aGl0ZWxpc3QsIFJlZ0V4cCwge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnTmF2aWdhdGlvblJvdXRlJyxcbiAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgIHBhcmFtTmFtZTogJ29wdGlvbnMud2hpdGVsaXN0JyxcbiAgICAgIH0pO1xuICAgICAgYXNzZXJ0LmlzQXJyYXlPZkNsYXNzKGJsYWNrbGlzdCwgUmVnRXhwLCB7XG4gICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LXJvdXRpbmcnLFxuICAgICAgICBjbGFzc05hbWU6ICdOYXZpZ2F0aW9uUm91dGUnLFxuICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgcGFyYW1OYW1lOiAnb3B0aW9ucy5ibGFja2xpc3QnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3VwZXIoKC4uLmFyZ3MpID0+IHRoaXMuX21hdGNoKC4uLmFyZ3MpLCBoYW5kbGVyKTtcblxuICAgIHRoaXMuX3doaXRlbGlzdCA9IHdoaXRlbGlzdDtcbiAgICB0aGlzLl9ibGFja2xpc3QgPSBibGFja2xpc3Q7XG4gIH1cblxuICAvKipcbiAgICogUm91dGVzIG1hdGNoIGhhbmRsZXIuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcGFyYW0ge0ZldGNoRXZlbnR9IGlucHV0LmV2ZW50XG4gICAqIEBwYXJhbSB7VVJMfSBpbnB1dC51cmxcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9tYXRjaCh7ZXZlbnQsIHVybH0pIHtcbiAgICBpZiAoZXZlbnQucmVxdWVzdC5tb2RlICE9PSAnbmF2aWdhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgY29uc3QgcGF0aG5hbWVBbmRTZWFyY2ggPSB1cmwucGF0aG5hbWUgKyB1cmwuc2VhcmNoO1xuXG4gICAgaWYgKHRoaXMuX2JsYWNrbGlzdC5zb21lKChyZWdFeHApID0+IHJlZ0V4cC50ZXN0KHBhdGhuYW1lQW5kU2VhcmNoKSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhgVGhlIG5hdmlnYXRpb24gcm91dGUgaXMgbm90IGJlaW5nIHVzZWQsIHNpbmNlIHRoZSBgICtcbiAgICAgICAgICBgcmVxdWVzdCBVUkwgbWF0Y2hlcyBib3RoIHRoZSB3aGl0ZWxpc3QgYW5kIGJsYWNrbGlzdC5gKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fd2hpdGVsaXN0LnNvbWUoKHJlZ0V4cCkgPT4gcmVnRXhwLnRlc3QocGF0aG5hbWVBbmRTZWFyY2gpKSkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKGBUaGUgbmF2aWdhdGlvbiByb3V0ZSBpcyBiZWluZyB1c2VkLmApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZyhcbiAgICAgICAgICBgVGhlIG5hdmlnYXRpb24gcm91dGUgaXMgbm90IGJlaW5nIHVzZWQsIHNpbmNlIHRoZSBgICtcbiAgICAgICAgICBgVVJMIGJlaW5nIG5hdmlnYXRlZCB0byBkb2Vzbid0IG1hdGNoIHRoZSB3aGl0ZWxpc3QuYFxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5leHBvcnQge05hdmlnYXRpb25Sb3V0ZX07XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge05hdmlnYXRpb25Sb3V0ZX0gZnJvbSAnLi9OYXZpZ2F0aW9uUm91dGUubWpzJztcbmltcG9ydCB7UmVnRXhwUm91dGV9IGZyb20gJy4vUmVnRXhwUm91dGUubWpzJztcbmltcG9ydCB7Um91dGVyfSBmcm9tICcuL1JvdXRlci5tanMnO1xuaW1wb3J0IHtSb3V0ZX0gZnJvbSAnLi9Sb3V0ZS5tanMnO1xuaW1wb3J0IHtXb3JrYm94RXJyb3J9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IubWpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0Lm1qcyc7XG5pbXBvcnQge2NhY2hlTmFtZXN9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9jYWNoZU5hbWVzLm1qcyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5tanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLm1qcyc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIGFzc2VydC5pc1N3RW52KCd3b3JrYm94LXJvdXRpbmcnKTtcbn1cblxuLyoqXG4gKiBAcHJpdmF0ZVxuICovXG5jbGFzcyBEZWZhdWx0Um91dGVyIGV4dGVuZHMgUm91dGVyIHtcbiAgLyoqXG4gICAqIEVhc2lseSByZWdpc3RlciBhIFJlZ0V4cCwgc3RyaW5nLCBvciBmdW5jdGlvbiB3aXRoIGEgY2FjaGluZ1xuICAgKiBzdHJhdGVneSB0byB0aGUgUm91dGVyLlxuICAgKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGdlbmVyYXRlIGEgUm91dGUgZm9yIHlvdSBpZiBuZWVkZWQgYW5kXG4gICAqIGNhbGwgW1JvdXRlci5yZWdpc3RlclJvdXRlKClde0BsaW5rXG4gICAqIHdvcmtib3gucm91dGluZy5Sb3V0ZXIjcmVnaXN0ZXJSb3V0ZX0uXG4gICAqXG4gICAqIEBwYXJhbSB7XG4gICAqIFJlZ0V4cHxcbiAgICogc3RyaW5nfFxuICAgKiB3b3JrYm94LnJvdXRpbmcuUm91dGV+bWF0Y2hDYWxsYmFja3xcbiAgICogd29ya2JveC5yb3V0aW5nLlJvdXRlXG4gICAqIH0gY2FwdHVyZVxuICAgKiBJZiB0aGUgY2FwdHVyZSBwYXJhbSBpcyBhIGBSb3V0ZWAsIGFsbCBvdGhlciBhcmd1bWVudHMgd2lsbCBiZSBpZ25vcmVkLlxuICAgKiBAcGFyYW0ge3dvcmtib3gucm91dGluZy5Sb3V0ZX5oYW5kbGVyQ2FsbGJhY2t9IGhhbmRsZXIgQSBjYWxsYmFja1xuICAgKiBmdW5jdGlvbiB0aGF0IHJldHVybnMgYSBQcm9taXNlIHJlc3VsdGluZyBpbiBhIFJlc3BvbnNlLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gW21ldGhvZD0nR0VUJ10gVGhlIEhUVFAgbWV0aG9kIHRvIG1hdGNoIHRoZSBSb3V0ZVxuICAgKiBhZ2FpbnN0LlxuICAgKiBAcmV0dXJuIHt3b3JrYm94LnJvdXRpbmcuUm91dGV9IFRoZSBnZW5lcmF0ZWQgYFJvdXRlYChVc2VmdWwgZm9yXG4gICAqIHVucmVnaXN0ZXJpbmcpLlxuICAgKlxuICAgKiBAYWxpYXMgd29ya2JveC5yb3V0aW5nLnJlZ2lzdGVyUm91dGVcbiAgICovXG4gIHJlZ2lzdGVyUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kID0gJ0dFVCcpIHtcbiAgICBsZXQgcm91dGU7XG5cbiAgICBpZiAodHlwZW9mIGNhcHR1cmUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCBjYXB0dXJlVXJsID0gbmV3IFVSTChjYXB0dXJlLCBsb2NhdGlvbik7XG5cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICghKGNhcHR1cmUuc3RhcnRzV2l0aCgnLycpIHx8IGNhcHR1cmUuc3RhcnRzV2l0aCgnaHR0cCcpKSkge1xuICAgICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ2ludmFsaWQtc3RyaW5nJywge1xuICAgICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtcm91dGluZycsXG4gICAgICAgICAgICBjbGFzc05hbWU6ICdEZWZhdWx0Um91dGVyJyxcbiAgICAgICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgICAgICBwYXJhbU5hbWU6ICdjYXB0dXJlJyxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIHdhbnQgdG8gY2hlY2sgaWYgRXhwcmVzcy1zdHlsZSB3aWxkY2FyZHMgYXJlIGluIHRoZSBwYXRobmFtZSBvbmx5LlxuICAgICAgICAvLyBUT0RPOiBSZW1vdmUgdGhpcyBsb2cgbWVzc2FnZSBpbiB2NC5cbiAgICAgICAgY29uc3QgdmFsdWVUb0NoZWNrID0gY2FwdHVyZS5zdGFydHNXaXRoKCdodHRwJykgP1xuICAgICAgICAgIGNhcHR1cmVVcmwucGF0aG5hbWUgOlxuICAgICAgICAgIGNhcHR1cmU7XG4gICAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vcGlsbGFyanMvcGF0aC10by1yZWdleHAjcGFyYW1ldGVyc1xuICAgICAgICBjb25zdCB3aWxkY2FyZHMgPSAnWyo6PytdJztcbiAgICAgICAgaWYgKHZhbHVlVG9DaGVjay5tYXRjaChuZXcgUmVnRXhwKGAke3dpbGRjYXJkc31gKSkpIHtcbiAgICAgICAgICBsb2dnZXIuZGVidWcoXG4gICAgICAgICAgICBgVGhlICckY2FwdHVyZScgcGFyYW1ldGVyIGNvbnRhaW5zIGFuIEV4cHJlc3Mtc3R5bGUgd2lsZGNhcmQgYCArXG4gICAgICAgICAgICBgY2hhcmFjdGVyICgke3dpbGRjYXJkc30pLiBTdHJpbmdzIGFyZSBub3cgYWx3YXlzIGludGVycHJldGVkIGFzIGAgK1xuICAgICAgICAgICAgYGV4YWN0IG1hdGNoZXM7IHVzZSBhIFJlZ0V4cCBmb3IgcGFydGlhbCBvciB3aWxkY2FyZCBtYXRjaGVzLmBcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IG1hdGNoQ2FsbGJhY2sgPSAoe3VybH0pID0+IHtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICBpZiAoKHVybC5wYXRobmFtZSA9PT0gY2FwdHVyZVVybC5wYXRobmFtZSkgJiZcbiAgICAgICAgICAgICAgKHVybC5vcmlnaW4gIT09IGNhcHR1cmVVcmwub3JpZ2luKSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKFxuICAgICAgICAgICAgICBgJHtjYXB0dXJlfSBvbmx5IHBhcnRpYWxseSBtYXRjaGVzIHRoZSBjcm9zcy1vcmlnaW4gVVJMIGAgK1xuICAgICAgICAgICAgICBgJHt1cmx9LiBUaGlzIHJvdXRlIHdpbGwgb25seSBoYW5kbGUgY3Jvc3Mtb3JpZ2luIHJlcXVlc3RzIGAgK1xuICAgICAgICAgICAgICBgaWYgdGhleSBtYXRjaCB0aGUgZW50aXJlIFVSTC5gXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB1cmwuaHJlZiA9PT0gY2FwdHVyZVVybC5ocmVmO1xuICAgICAgfTtcblxuICAgICAgcm91dGUgPSBuZXcgUm91dGUobWF0Y2hDYWxsYmFjaywgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcbiAgICAgIHJvdXRlID0gbmV3IFJlZ0V4cFJvdXRlKGNhcHR1cmUsIGhhbmRsZXIsIG1ldGhvZCk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgY2FwdHVyZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcm91dGUgPSBuZXcgUm91dGUoY2FwdHVyZSwgaGFuZGxlciwgbWV0aG9kKTtcbiAgICB9IGVsc2UgaWYgKGNhcHR1cmUgaW5zdGFuY2VvZiBSb3V0ZSkge1xuICAgICAgcm91dGUgPSBjYXB0dXJlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgV29ya2JveEVycm9yKCd1bnN1cHBvcnRlZC1yb3V0ZS10eXBlJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnRGVmYXVsdFJvdXRlcicsXG4gICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJSb3V0ZScsXG4gICAgICAgIHBhcmFtTmFtZTogJ2NhcHR1cmUnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgc3VwZXIucmVnaXN0ZXJSb3V0ZShyb3V0ZSk7XG4gICAgcmV0dXJuIHJvdXRlO1xuICB9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVyIGEgcm91dGUgdGhhdCB3aWxsIHJldHVybiBhIHByZWNhY2hlZCBmaWxlIGZvciBhIG5hdmlnYXRpb25cbiAgICogcmVxdWVzdC4gVGhpcyBpcyB1c2VmdWwgZm9yIHRoZVxuICAgKiBbYXBwbGljYXRpb24gc2hlbGwgcGF0dGVybl17QGxpbmsgaHR0cHM6Ly9kZXZlbG9wZXJzLmdvb2dsZS5jb20vd2ViL2Z1bmRhbWVudGFscy9hcmNoaXRlY3R1cmUvYXBwLXNoZWxsfS5cbiAgICpcbiAgICogVGhpcyBtZXRob2Qgd2lsbCBnZW5lcmF0ZSBhXG4gICAqIFtOYXZpZ2F0aW9uUm91dGVde0BsaW5rIHdvcmtib3gucm91dGluZy5OYXZpZ2F0aW9uUm91dGV9XG4gICAqIGFuZCBjYWxsXG4gICAqIFtSb3V0ZXIucmVnaXN0ZXJSb3V0ZSgpXXtAbGluayB3b3JrYm94LnJvdXRpbmcuUm91dGVyI3JlZ2lzdGVyUm91dGV9XG4gICAqIC5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlZEFzc2V0VXJsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmNhY2hlTmFtZV0gQ2FjaGUgbmFtZSB0byBzdG9yZSBhbmQgcmV0cmlldmVcbiAgICogcmVxdWVzdHMuIERlZmF1bHRzIHRvIHByZWNhY2hlIGNhY2hlIG5hbWUgcHJvdmlkZWQgYnlcbiAgICogW3dvcmtib3gtY29yZS5jYWNoZU5hbWVzXXtAbGluayB3b3JrYm94LmNvcmUuY2FjaGVOYW1lc30uXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gW29wdGlvbnMuYmxhY2tsaXN0PVtdXSBJZiBhbnkgb2YgdGhlc2UgcGF0dGVybnNcbiAgICogbWF0Y2gsIHRoZSByb3V0ZSB3aWxsIG5vdCBoYW5kbGUgdGhlIHJlcXVlc3QgKGV2ZW4gaWYgYSB3aGl0ZWxpc3QgZW50cnlcbiAgICogbWF0Y2hlcykuXG4gICAqIEBwYXJhbSB7QXJyYXk8UmVnRXhwPn0gW29wdGlvbnMud2hpdGVsaXN0PVsvLi9dXSBJZiBhbnkgb2YgdGhlc2UgcGF0dGVybnNcbiAgICogbWF0Y2ggdGhlIFVSTCdzIHBhdGhuYW1lIGFuZCBzZWFyY2ggcGFyYW1ldGVyLCB0aGUgcm91dGUgd2lsbCBoYW5kbGUgdGhlXG4gICAqIHJlcXVlc3QgKGFzc3VtaW5nIHRoZSBibGFja2xpc3QgZG9lc24ndCBtYXRjaCkuXG4gICAqIEByZXR1cm4ge3dvcmtib3gucm91dGluZy5OYXZpZ2F0aW9uUm91dGV9IFJldHVybnMgdGhlIGdlbmVyYXRlZFxuICAgKiBSb3V0ZS5cbiAgICpcbiAgICogQGFsaWFzIHdvcmtib3gucm91dGluZy5yZWdpc3Rlck5hdmlnYXRpb25Sb3V0ZVxuICAgKi9cbiAgcmVnaXN0ZXJOYXZpZ2F0aW9uUm91dGUoY2FjaGVkQXNzZXRVcmwsIG9wdGlvbnMgPSB7fSkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNUeXBlKGNhY2hlZEFzc2V0VXJsLCAnc3RyaW5nJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1yb3V0aW5nJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnW2RlZmF1bHQgZXhwb3J0XScsXG4gICAgICAgIGZ1bmNOYW1lOiAncmVnaXN0ZXJOYXZpZ2F0aW9uUm91dGUnLFxuICAgICAgICBwYXJhbU5hbWU6ICdjYWNoZWRBc3NldFVybCcsXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBjYWNoZU5hbWUgPSBjYWNoZU5hbWVzLmdldFByZWNhY2hlTmFtZShvcHRpb25zLmNhY2hlTmFtZSk7XG4gICAgY29uc3QgaGFuZGxlciA9ICgpID0+IGNhY2hlcy5tYXRjaChjYWNoZWRBc3NldFVybCwge2NhY2hlTmFtZX0pO1xuICAgIGNvbnN0IHJvdXRlID0gbmV3IE5hdmlnYXRpb25Sb3V0ZShoYW5kbGVyLCB7XG4gICAgICB3aGl0ZWxpc3Q6IG9wdGlvbnMud2hpdGVsaXN0LFxuICAgICAgYmxhY2tsaXN0OiBvcHRpb25zLmJsYWNrbGlzdCxcbiAgICB9KTtcbiAgICBzdXBlci5yZWdpc3RlclJvdXRlKFxuICAgICAgcm91dGVcbiAgICApO1xuICAgIHJldHVybiByb3V0ZTtcbiAgfVxufVxuXG5jb25zdCByb3V0ZXIgPSBuZXcgRGVmYXVsdFJvdXRlcigpO1xuXG4vLyBCeSBkZWZhdWx0LCByZWdpc3RlciBhIGZldGNoIGV2ZW50IGxpc3RlbmVyIHRoYXQgd2lsbCByZXNwb25kIHRvIGEgcmVxdWVzdFxuLy8gb25seSBpZiB0aGVyZSdzIGEgbWF0Y2hpbmcgcm91dGUuXG5zZWxmLmFkZEV2ZW50TGlzdGVuZXIoJ2ZldGNoJywgKGV2ZW50KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlUHJvbWlzZSA9IHJvdXRlci5oYW5kbGVSZXF1ZXN0KGV2ZW50KTtcbiAgaWYgKHJlc3BvbnNlUHJvbWlzZSkge1xuICAgIGV2ZW50LnJlc3BvbmRXaXRoKHJlc3BvbnNlUHJvbWlzZSk7XG4gIH1cbn0pO1xuXG5leHBvcnQgZGVmYXVsdCByb3V0ZXI7XG4iLCIvKlxuICBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLlxuXG4gIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAgWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG5cbiAgICAgIGh0dHBzOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcblxuICBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5cbmltcG9ydCAqIGFzIHB1YmxpY0FQSSBmcm9tICcuL19wdWJsaWMubWpzJztcbmltcG9ydCBkZWZhdWx0RXhwb3J0IGZyb20gJy4vX2RlZmF1bHQubWpzJztcbmltcG9ydCAnLi9fdmVyc2lvbi5tanMnO1xuXG5jb25zdCBmaW5hbEV4cG9ydCA9IE9iamVjdC5hc3NpZ24oZGVmYXVsdEV4cG9ydCwgcHVibGljQVBJKTtcblxuZXhwb3J0IGRlZmF1bHQgZmluYWxFeHBvcnQ7XG4iXSwibmFtZXMiOlsid29ya2JveCIsInYiLCJlIiwiaGFuZGxlciIsImhhbmRsZSIsIlJvdXRlIiwibWF0Y2giLCJtZXRob2QiLCJub3JtYWxpemVIYW5kbGVyIiwiUmVnRXhwUm91dGUiLCJyZWdFeHAiLCJ1cmwiLCJyZXN1bHQiLCJleGVjIiwiaHJlZiIsIm9yaWdpbiIsImxvY2F0aW9uIiwiaW5kZXgiLCJzbGljZSIsIlJvdXRlciIsIl9yb3V0ZXMiLCJNYXAiLCJldmVudCIsIlVSTCIsInJlcXVlc3QiLCJwcm90b2NvbCIsInN0YXJ0c1dpdGgiLCJwYXJhbXMiLCJ0aGlzIiwiX2ZpbmRIYW5kbGVyQW5kUGFyYW1zIiwiX2RlZmF1bHRIYW5kbGVyIiwicmVzcG9uc2VQcm9taXNlIiwiZXJyIiwiUHJvbWlzZSIsInJlamVjdCIsIl9jYXRjaEhhbmRsZXIiLCJjYXRjaCIsInJvdXRlcyIsImdldCIsInJvdXRlIiwibWF0Y2hSZXN1bHQiLCJBcnJheSIsImlzQXJyYXkiLCJsZW5ndGgiLCJ1bmRlZmluZWQiLCJjb25zdHJ1Y3RvciIsIk9iamVjdCIsImtleXMiLCJoYXMiLCJzZXQiLCJwdXNoIiwiV29ya2JveEVycm9yIiwicm91dGVJbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJOYXZpZ2F0aW9uUm91dGUiLCJ3aGl0ZWxpc3QiLCJibGFja2xpc3QiLCJhcmdzIiwiX21hdGNoIiwiX3doaXRlbGlzdCIsIl9ibGFja2xpc3QiLCJtb2RlIiwicGF0aG5hbWVBbmRTZWFyY2giLCJwYXRobmFtZSIsInNlYXJjaCIsInNvbWUiLCJ0ZXN0IiwiRGVmYXVsdFJvdXRlciIsImNhcHR1cmUiLCJjYXB0dXJlVXJsIiwiUmVnRXhwIiwicmVnaXN0ZXJSb3V0ZSIsImNhY2hlZEFzc2V0VXJsIiwib3B0aW9ucyIsImNhY2hlTmFtZSIsImNhY2hlTmFtZXMiLCJnZXRQcmVjYWNoZU5hbWUiLCJjYWNoZXMiLCJyb3V0ZXIiLCJzZWxmIiwiYWRkRXZlbnRMaXN0ZW5lciIsImhhbmRsZVJlcXVlc3QiLCJyZXNwb25kV2l0aCIsImFzc2lnbiIsImRlZmF1bHRFeHBvcnQiLCJwdWJsaWNBUEkiXSwibWFwcGluZ3MiOiI4RUFBQSxTQUFTQSxRQUFRQyxFQUFFLGlDQUFpQyxFQUFHLE1BQU1DLElDeUI3RCxNQUFnQkMsR0FDVkEsR0FBOEIsaUJBQVpBLEVBU2JBLEdBVUNDLE9B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"}