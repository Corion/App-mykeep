{"version":3,"file":"workbox-cache-expiration.prod.js","sources":["packages/workbox-cache-expiration/_version.mjs","packages/workbox-cache-expiration/models/CacheTimestampsModel.mjs","packages/workbox-cache-expiration/CacheExpiration.mjs","packages/workbox-cache-expiration/CacheExpirationPlugin.mjs"],"sourcesContent":["try{self.workbox.v['workbox:cache-expiration:3.0.0-alpha.1']=1;}catch(e){} // eslint-disable-line","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {DBWrapper} from 'workbox-core/_private/DBWrapper.mjs';\nimport '../_version.mjs';\n\nconst URL_KEY = 'url';\nconst TIMESTAMP_KEY = 'timestamp';\n\n/**\n * Returns the timestamp model.\n *\n * @private\n */\nclass CacheTimestampsModel {\n  /**\n   *\n   * @param {string} cacheName\n   *\n   * @private\n   */\n  constructor(cacheName) {\n    // TODO Check cacheName\n\n    this._cacheName = cacheName;\n    this._storeName = cacheName;\n\n    this._db = new DBWrapper('workbox-cache-expiration', 1, {\n      onupgradeneeded: (evt) => evt.target.result\n          .createObjectStore(this._storeName, {keyPath: URL_KEY})\n          .createIndex(TIMESTAMP_KEY, TIMESTAMP_KEY, {unique: false}),\n    });\n  }\n\n  /**\n   * @param {string} url\n   * @param {number} timestamp\n   *\n   * @private\n   */\n  async setTimestamp(url, timestamp) {\n    await this._db.put(this._storeName, {\n      [URL_KEY]: new URL(url, location).href,\n      [TIMESTAMP_KEY]: timestamp,\n    });\n  }\n\n  /**\n   * Get all of the timestamps in the indexedDB.\n   *\n   * @return {Array<Objects>}\n   *\n   * @private\n   */\n  async getAllTimestamps() {\n    return await this._db.getAllMatching(this._storeName, {\n      index: TIMESTAMP_KEY,\n    });\n  }\n\n  /**\n   * Returns the timestamp stored for a given URL.\n   *\n   * @param {string} url\n   * @return {number}\n   *\n   * @private\n   */\n  async getTimestamp(url) {\n    const timestampObject = await this._db.get(this._storeName, url);\n    return timestampObject.timestamp;\n  }\n\n  /**\n   * @param {string} url\n   *\n   * @private\n   */\n  async deleteUrl(url) {\n    await this._db.delete(this._storeName, new URL(url, location).href);\n  }\n}\n\nexport default CacheTimestampsModel;\n","/*\n  Copyright 2017 Google Inc.\n\n  Licensed under the Apache License, Version 2.0 (the \"License\");\n  you may not use this file except in compliance with the License.\n  You may obtain a copy of the License at\n\n      https://www.apache.org/licenses/LICENSE-2.0\n\n  Unless required by applicable law or agreed to in writing, software\n  distributed under the License is distributed on an \"AS IS\" BASIS,\n  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n  See the License for the specific language governing permissions and\n  limitations under the License.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {logger} from 'workbox-core/_private/logger.mjs';\nimport CacheTimestampsModel from './models/CacheTimestampsModel.mjs';\nimport './_version.mjs';\n\n/**\n * The `CacheExpiration` class allows you define an expiration and / or\n * limit on the number of responses stored in a\n * [`Cache`](https://developer.mozilla.org/en-US/docs/Web/API/Cache).\n *\n * @memberof workbox.expiration\n */\nclass CacheExpiration {\n  /**\n   * To construct a new CacheExpiration instance you must provide at least\n   * one of the `config` properties.\n   *\n   * @param {string} cacheName Name of the cache to apply restrictions to.\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(cacheName, config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-cache-expiration',\n        className: 'CacheExpiration',\n        funcName: 'constructor',\n        paramName: 'cacheName',\n      });\n\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n\n        // TODO: Assert is positive\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpiration',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n\n        // TODO: Assert is positive\n      }\n    }\n\n    this._isRunning = false;\n    this._rerunRequested = false;\n    this._maxEntries = config.maxEntries;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheName = cacheName;\n    this._timestampModel = new CacheTimestampsModel(cacheName);\n  }\n\n  /**\n   * Expires entries for the given cache and given criteria.\n   */\n  async expireEntries() {\n    if (this._isRunning) {\n      this._rerunRequested = true;\n      return;\n    }\n    this._isRunning = true;\n\n    const now = Date.now();\n\n    // First, expire old entries, if maxAgeSeconds is set.\n    const oldEntries = await this._findOldEntries(now);\n\n    // Once that's done, check for the maximum size.\n    const extraEntries = await this._findExtraEntries();\n\n    // Use a Set to remove any duplicates following the concatenation, then\n    // convert back into an array.\n    const allUrls = [...new Set(oldEntries.concat(extraEntries))];\n\n    await Promise.all([\n      this._deleteFromCache(allUrls),\n      this._deleteFromIDB(allUrls),\n    ]);\n\n    if (process.env.NODE_ENV !== 'production') {\n      // TODO: break apart entries deleted due to expiration vs size restraints\n      if (allUrls.length > 0) {\n        logger.groupCollapsed(\n          `Expired ${allUrls.length} ` +\n          `${allUrls.length === 1 ? 'entry' : 'entries'} and removed ` +\n          `${allUrls.length === 1 ? 'it' : 'them'} from the ` +\n          `'${this._cacheName}' cache.`);\n        logger.log(\n          `Expired the following ${allUrls.length === 1 ? 'URL' : 'URLs'}:`);\n        allUrls.forEach((url) => logger.log(`    ${url}`));\n        logger.groupEnd();\n      } else {\n        logger.debug(`Cache expiration ran and found no entries to remove.`);\n      }\n    }\n\n    this._isRunning = false;\n    if (this._rerunRequested) {\n      this._rerunRequested = false;\n      this.expireEntries();\n    }\n  }\n\n  /**\n   * Expires entries based on the the maximum age.\n   *\n   * @param {number} expireFromTimestamp A timestamp.\n   * @return {Promise<Array<string>>} A list of the URLs that were expired.\n   *\n   * @private\n   */\n  async _findOldEntries(expireFromTimestamp) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(expireFromTimestamp, 'number', {\n        moduleName: 'workbox-cache-expiration',\n        className: 'CacheExpiration',\n        funcName: '_findOldEntries',\n        paramName: 'expireFromTimestamp',\n      });\n    }\n\n    if (!this._maxAgeSeconds) {\n      return [];\n    }\n\n    const expireOlderThan = expireFromTimestamp - (this._maxAgeSeconds * 1000);\n    const timestamps = await this._timestampModel.getAllTimestamps();\n    const expiredUrls = [];\n    timestamps.forEach((timestampDetails) => {\n      if (timestampDetails.timestamp < expireOlderThan) {\n        expiredUrls.push(timestampDetails.url);\n      }\n    });\n\n    return expiredUrls;\n  }\n\n  /**\n   * @return {Promise<Array>}\n   *\n   * @private\n   */\n  async _findExtraEntries() {\n    const extraUrls = [];\n\n    if (!this._maxEntries) {\n      return [];\n    }\n\n    const timestamps = await this._timestampModel.getAllTimestamps();\n    while (timestamps.length > this._maxEntries) {\n      const lastUsed = timestamps.shift();\n      extraUrls.push(lastUsed.url);\n    }\n\n    return extraUrls;\n  }\n\n  /**\n   * @param {Array<string>} urls Array of URLs to delete from cache.\n   *\n   * @private\n   */\n  async _deleteFromCache(urls) {\n    const cache = await caches.open(this._cacheName);\n    for (const url of urls) {\n      await cache.delete(url);\n    }\n  }\n\n  /**\n   * @param {Array<string>} urls Array of URLs to delete from IDB\n   *\n   * @private\n   */\n  async _deleteFromIDB(urls) {\n    for (const url of urls) {\n      await this._timestampModel.deleteUrl(url);\n    }\n  }\n\n  /**\n   * Update the timestamp for the given URL. This ensures the when\n   * removing entries based on maximum entries, most recently used\n   * is accurate or when expiring, the timestamp is up-to-date.\n   *\n   * @param {string} url\n   */\n  async updateTimestamp(url) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(url, 'string', {\n        moduleName: 'workbox-cache-expiration',\n        className: 'CacheExpiration',\n        funcName: 'updateTimestamp',\n        paramName: 'url',\n      });\n    }\n\n    const urlObject = new URL(url, location);\n    urlObject.hash = '';\n\n    await this._timestampModel.setTimestamp(urlObject.href, Date.now());\n  }\n\n  /**\n   * Can be used to check if a URL has expired or not before it's used.\n   *\n   * This requires a look up from IndexedDB, so can be slow.\n   *\n   * Note: This method will not remove the cached entry, call\n   * `expireEntries()` to remove indexedDB and Cache entries.\n   *\n   * @param {string} url\n   * @return {boolean}\n   */\n  async isURLExpired(url) {\n    if (!this._maxAgeSeconds) {\n      throw new WorkboxError(`expired-test-without-max-age`, {\n        methodName: 'isURLExpired',\n        paramName: 'maxAgeSeconds',\n      });\n    }\n    const urlObject = new URL(url, location);\n    urlObject.hash = '';\n\n    const timestamp = await this._timestampModel.getTimestamp(urlObject.href);\n    const expireOlderThan = Date.now() - (this._maxAgeSeconds * 1000);\n    return (timestamp < expireOlderThan);\n  }\n}\n\nexport {CacheExpiration};\n","/*\n Copyright 2016 Google Inc. All Rights Reserved.\n Licensed under the Apache License, Version 2.0 (the \"License\");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an \"AS IS\" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n*/\n\nimport {WorkboxError} from 'workbox-core/_private/WorkboxError.mjs';\nimport {assert} from 'workbox-core/_private/assert.mjs';\nimport {CacheExpiration} from './CacheExpiration.mjs';\nimport './_version.mjs';\n\n/**\n * This plugin can be used in the Workbox API's to regularly enforce a\n * limit on the age and / or the number of cached requests.\n *\n * Whenever a cached request is used or updated, this plugin will look\n * at the used Cache and remove any old or extra requests.\n *\n * When using `maxAgeSeconds`, requests may be used *once* after expiring\n * because the expiration clean up will not have occured until *after* the\n * cached request has been used. If the request has a \"Date\" header, then\n * a light weight expiration check is performed and the request will not be\n * used immediately.\n *\n * When using `maxEntries`, the last request to be used will be the request\n * that is removed from the Cache.\n *\n * @memberof workbox.expiration\n */\nclass CacheExpirationPlugin {\n  /**\n   * @param {Object} config\n   * @param {number} [config.maxEntries] The maximum number of entries to cache.\n   * Entries used the least will be removed as the maximum is reached.\n   * @param {number} [config.maxAgeSeconds] The maximum age of an entry before\n   * it's treated as stale and removed.\n   */\n  constructor(config = {}) {\n    if (process.env.NODE_ENV !== 'production') {\n      if (!(config.maxEntries || config.maxAgeSeconds)) {\n        throw new WorkboxError('max-entries-or-age-required', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpirationPlugin',\n          funcName: 'constructor',\n        });\n      }\n\n      if (config.maxEntries) {\n        assert.isType(config.maxEntries, 'number', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpirationPlugin',\n          funcName: 'constructor',\n          paramName: 'config.maxEntries',\n        });\n      }\n\n      if (config.maxAgeSeconds) {\n        assert.isType(config.maxAgeSeconds, 'number', {\n          moduleName: 'workbox-cache-expiration',\n          className: 'CacheExpirationPlugin',\n          funcName: 'constructor',\n          paramName: 'config.maxAgeSeconds',\n        });\n      }\n    }\n\n    this._config = config;\n    this._maxAgeSeconds = config.maxAgeSeconds;\n    this._cacheExpirations = new Map();\n  }\n\n  /**\n   * A simple helper method to return a CacheExpiration instance for a given\n   * cache name.\n   *\n   * @param {string} cacheName\n   * @return {CacheExpiration}\n   *\n   * @private\n   */\n  _getCacheExpiration(cacheName) {\n    let cacheExpiration = this._cacheExpirations.get(cacheName);\n    if (!cacheExpiration) {\n      cacheExpiration = new CacheExpiration(cacheName, this._config);\n      this._cacheExpirations.set(cacheName, cacheExpiration);\n    }\n    return cacheExpiration;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.runtimeCaching` handlers when a `Response` is about to be returned\n   * from a [Cache](https://developer.mozilla.org/en-US/docs/Web/API/Cache) to\n   * the handler. It allows the `Response` to be inspected for freshness and\n   * prevents it from being used if the `Response`'s `Date` header value is\n   * older than the configured `maxAgeSeconds`.\n   *\n   * @param {Object} input\n   * @param {string} input.cacheName Name of the cache the responses belong to.\n   * @param {Response} input.cachedResponse The `Response` object that's been\n   *        read from a cache and whose freshness should be checked.\n   * @return {Response} Either the `cachedResponse`, if it's\n   *         fresh, or `null` if the `Response` is older than `maxAgeSeconds`.\n   *\n   * @private\n   */\n  cachedResponseWillBeUsed({cacheName, cachedResponse}) {\n    let isFresh = this._isResponseDateFresh(cachedResponse);\n\n    // Expire entries to ensure that even if the expiration date has\n    // expired, it'll only be used once.\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    cacheExpiration.expireEntries();\n\n    return isFresh ? cachedResponse : null;\n  }\n\n  /**\n   * @param {Response} cachedResponse\n   * @return {boolean}\n   *\n   * @private\n   */\n  _isResponseDateFresh(cachedResponse) {\n    if (!this._maxAgeSeconds) {\n      // We aren't expiring by age, so return true, it's fresh\n      return true;\n    }\n\n    // Check if the 'date' header will suffice a quick expiration check.\n    // See https://github.com/GoogleChromeLabs/sw-toolbox/issues/164 for\n    // discussion.\n    const dateHeaderTimestamp = this._getDateHeaderTimestamp(cachedResponse);\n    if (dateHeaderTimestamp === null) {\n      // Unable to parse date, so assume it's fresh.\n      return true;\n    }\n\n    // If we have a valid headerTime, then our response is fresh iff the\n    // headerTime plus maxAgeSeconds is greater than the current time.\n    const now = Date.now();\n    return dateHeaderTimestamp >= now - (this._maxAgeSeconds * 1000);\n  }\n\n  /**\n   * This method will extract the data header and parse it into a useful\n   * value.\n   *\n   * @param {Response} cachedResponse\n   * @return {number}\n   *\n   * @private\n   */\n  _getDateHeaderTimestamp(cachedResponse) {\n    const dateHeader = cachedResponse.headers.get('date');\n    const parsedDate = new Date(dateHeader);\n    const headerTime = parsedDate.getTime();\n\n    // If the Date header was invalid for some reason, parsedDate.getTime()\n    // will return NaN.\n    if (isNaN(headerTime)) {\n      return null;\n    }\n\n    return headerTime;\n  }\n\n  /**\n   * A \"lifecycle\" callback that will be triggered automatically by the\n   * `workbox.runtimeCaching` handlers when an entry is added to a cache.\n   *\n   * @param {Object} input\n   * @param {string} input.cacheName Name of the cache the responses belong to.\n   * @param {string} input.request The Request for the cached entry.\n   *\n   * @private\n   */\n  async cacheDidUpdate({cacheName, request}) {\n    if (process.env.NODE_ENV !== 'production') {\n      assert.isType(cacheName, 'string', {\n        moduleName: 'workbox-cache-expiration',\n        className: 'CacheExpirationPlugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'cacheName',\n      });\n      assert.isInstance(request, Request, {\n        moduleName: 'workbox-cache-expiration',\n        className: 'CacheExpirationPlugin',\n        funcName: 'cacheDidUpdate',\n        paramName: 'request',\n      });\n    }\n\n    const cacheExpiration = this._getCacheExpiration(cacheName);\n    await cacheExpiration.updateTimestamp(request.url);\n    await cacheExpiration.expireEntries();\n  }\n}\n\nexport {CacheExpirationPlugin};\n"],"names":["workbox","v","e","CacheTimestampsModel","cacheName","_cacheName","_storeName","_db","DBWrapper","evt","target","result","createObjectStore","this","keyPath","createIndex","unique","url","timestamp","_this","put","URL","location","href","_this2","getAllMatching","_this3","get","_this4","delete","CacheExpiration","config","_isRunning","_rerunRequested","_maxEntries","maxEntries","_maxAgeSeconds","maxAgeSeconds","_timestampModel","now","Date","oldEntries","_findOldEntries","extraEntries","_findExtraEntries","allUrls","Set","concat","Promise","all","_deleteFromCache","_deleteFromIDB","expireEntries","expireFromTimestamp","expireOlderThan","expiredUrls","getAllTimestamps","forEach","timestampDetails","push","extraUrls","timestamps","length","lastUsed","shift","urls","cache","caches","open","_this5","deleteUrl","urlObject","hash","_this6","setTimestamp","_this7","WorkboxError","getTimestamp","CacheExpirationPlugin","_config","_cacheExpirations","Map","cacheExpiration","set","cachedResponse","isFresh","_isResponseDateFresh","_getCacheExpiration","dateHeaderTimestamp","_getDateHeaderTimestamp","dateHeader","headers","headerTime","getTime","isNaN","request","updateTimestamp"],"mappings":"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","preExistingComment":"//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjpudWxsLCJzb3VyY2VzIjpbIi9Vc2Vycy9tYXR0Z2F1bnQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4xL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbi9fdmVyc2lvbi5tanMiLCIvVXNlcnMvbWF0dGdhdW50L1Byb2plY3RzL0NvZGUvd29ya2JveC9nZW5lcmF0ZWQtcmVsZWFzZS1maWxlcy92My4wLjAtYWxwaGEuMS9zb3VyY2UtY29kZS9wYWNrYWdlcy93b3JrYm94LWNhY2hlLWV4cGlyYXRpb24vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLm1qcyIsIi9Vc2Vycy9tYXR0Z2F1bnQvUHJvamVjdHMvQ29kZS93b3JrYm94L2dlbmVyYXRlZC1yZWxlYXNlLWZpbGVzL3YzLjAuMC1hbHBoYS4xL3NvdXJjZS1jb2RlL3BhY2thZ2VzL3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbi9DYWNoZUV4cGlyYXRpb24ubWpzIiwiL1VzZXJzL21hdHRnYXVudC9Qcm9qZWN0cy9Db2RlL3dvcmtib3gvZ2VuZXJhdGVkLXJlbGVhc2UtZmlsZXMvdjMuMC4wLWFscGhhLjEvc291cmNlLWNvZGUvcGFja2FnZXMvd29ya2JveC1jYWNoZS1leHBpcmF0aW9uL0NhY2hlRXhwaXJhdGlvblBsdWdpbi5tanMiXSwic291cmNlc0NvbnRlbnQiOlsidHJ5e3NlbGYud29ya2JveC52Wyd3b3JrYm94OmNhY2hlLWV4cGlyYXRpb246My4wLjAtYWxwaGEuMSddPTE7fWNhdGNoKGUpe30gLy8gZXNsaW50LWRpc2FibGUtbGluZSIsIi8qXG4gIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuXG5cbiAgTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAgeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcblxuICAgICAgaHR0cHM6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuXG4gIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAgU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiovXG5cbmltcG9ydCB7REJXcmFwcGVyfSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvREJXcmFwcGVyLm1qcyc7XG5pbXBvcnQgJy4uL192ZXJzaW9uLm1qcyc7XG5cbmNvbnN0IFVSTF9LRVkgPSAndXJsJztcbmNvbnN0IFRJTUVTVEFNUF9LRVkgPSAndGltZXN0YW1wJztcblxuLyoqXG4gKiBSZXR1cm5zIHRoZSB0aW1lc3RhbXAgbW9kZWwuXG4gKlxuICogQHByaXZhdGVcbiAqL1xuY2xhc3MgQ2FjaGVUaW1lc3RhbXBzTW9kZWwge1xuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNhY2hlTmFtZVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgY29uc3RydWN0b3IoY2FjaGVOYW1lKSB7XG4gICAgLy8gVE9ETyBDaGVjayBjYWNoZU5hbWVcblxuICAgIHRoaXMuX2NhY2hlTmFtZSA9IGNhY2hlTmFtZTtcbiAgICB0aGlzLl9zdG9yZU5hbWUgPSBjYWNoZU5hbWU7XG5cbiAgICB0aGlzLl9kYiA9IG5ldyBEQldyYXBwZXIoJ3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbicsIDEsIHtcbiAgICAgIG9udXBncmFkZW5lZWRlZDogKGV2dCkgPT4gZXZ0LnRhcmdldC5yZXN1bHRcbiAgICAgICAgICAuY3JlYXRlT2JqZWN0U3RvcmUodGhpcy5fc3RvcmVOYW1lLCB7a2V5UGF0aDogVVJMX0tFWX0pXG4gICAgICAgICAgLmNyZWF0ZUluZGV4KFRJTUVTVEFNUF9LRVksIFRJTUVTVEFNUF9LRVksIHt1bmlxdWU6IGZhbHNlfSksXG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcGFyYW0ge251bWJlcn0gdGltZXN0YW1wXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBzZXRUaW1lc3RhbXAodXJsLCB0aW1lc3RhbXApIHtcbiAgICBhd2FpdCB0aGlzLl9kYi5wdXQodGhpcy5fc3RvcmVOYW1lLCB7XG4gICAgICBbVVJMX0tFWV06IG5ldyBVUkwodXJsLCBsb2NhdGlvbikuaHJlZixcbiAgICAgIFtUSU1FU1RBTVBfS0VZXTogdGltZXN0YW1wLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCBhbGwgb2YgdGhlIHRpbWVzdGFtcHMgaW4gdGhlIGluZGV4ZWREQi5cbiAgICpcbiAgICogQHJldHVybiB7QXJyYXk8T2JqZWN0cz59XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBnZXRBbGxUaW1lc3RhbXBzKCkge1xuICAgIHJldHVybiBhd2FpdCB0aGlzLl9kYi5nZXRBbGxNYXRjaGluZyh0aGlzLl9zdG9yZU5hbWUsIHtcbiAgICAgIGluZGV4OiBUSU1FU1RBTVBfS0VZLFxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIHRpbWVzdGFtcCBzdG9yZWQgZm9yIGEgZ2l2ZW4gVVJMLlxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gdXJsXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGdldFRpbWVzdGFtcCh1cmwpIHtcbiAgICBjb25zdCB0aW1lc3RhbXBPYmplY3QgPSBhd2FpdCB0aGlzLl9kYi5nZXQodGhpcy5fc3RvcmVOYW1lLCB1cmwpO1xuICAgIHJldHVybiB0aW1lc3RhbXBPYmplY3QudGltZXN0YW1wO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB1cmxcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGRlbGV0ZVVybCh1cmwpIHtcbiAgICBhd2FpdCB0aGlzLl9kYi5kZWxldGUodGhpcy5fc3RvcmVOYW1lLCBuZXcgVVJMKHVybCwgbG9jYXRpb24pLmhyZWYpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IENhY2hlVGltZXN0YW1wc01vZGVsO1xuIiwiLypcbiAgQ29weXJpZ2h0IDIwMTcgR29vZ2xlIEluYy5cblxuICBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuXG4gICAgICBodHRwczovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG5cbiAgVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuKi9cblxuaW1wb3J0IHtXb3JrYm94RXJyb3J9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9Xb3JrYm94RXJyb3IubWpzJztcbmltcG9ydCB7YXNzZXJ0fSBmcm9tICd3b3JrYm94LWNvcmUvX3ByaXZhdGUvYXNzZXJ0Lm1qcyc7XG5pbXBvcnQge2xvZ2dlcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL2xvZ2dlci5tanMnO1xuaW1wb3J0IENhY2hlVGltZXN0YW1wc01vZGVsIGZyb20gJy4vbW9kZWxzL0NhY2hlVGltZXN0YW1wc01vZGVsLm1qcyc7XG5pbXBvcnQgJy4vX3ZlcnNpb24ubWpzJztcblxuLyoqXG4gKiBUaGUgYENhY2hlRXhwaXJhdGlvbmAgY2xhc3MgYWxsb3dzIHlvdSBkZWZpbmUgYW4gZXhwaXJhdGlvbiBhbmQgLyBvclxuICogbGltaXQgb24gdGhlIG51bWJlciBvZiByZXNwb25zZXMgc3RvcmVkIGluIGFcbiAqIFtgQ2FjaGVgXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ2FjaGUpLlxuICpcbiAqIEBtZW1iZXJvZiB3b3JrYm94LmV4cGlyYXRpb25cbiAqL1xuY2xhc3MgQ2FjaGVFeHBpcmF0aW9uIHtcbiAgLyoqXG4gICAqIFRvIGNvbnN0cnVjdCBhIG5ldyBDYWNoZUV4cGlyYXRpb24gaW5zdGFuY2UgeW91IG11c3QgcHJvdmlkZSBhdCBsZWFzdFxuICAgKiBvbmUgb2YgdGhlIGBjb25maWdgIHByb3BlcnRpZXMuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdG8gYXBwbHkgcmVzdHJpY3Rpb25zIHRvLlxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEVudHJpZXNdIFRoZSBtYXhpbXVtIG51bWJlciBvZiBlbnRyaWVzIHRvIGNhY2hlLlxuICAgKiBFbnRyaWVzIHVzZWQgdGhlIGxlYXN0IHdpbGwgYmUgcmVtb3ZlZCBhcyB0aGUgbWF4aW11bSBpcyByZWFjaGVkLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW2NvbmZpZy5tYXhBZ2VTZWNvbmRzXSBUaGUgbWF4aW11bSBhZ2Ugb2YgYW4gZW50cnkgYmVmb3JlXG4gICAqIGl0J3MgdHJlYXRlZCBhcyBzdGFsZSBhbmQgcmVtb3ZlZC5cbiAgICovXG4gIGNvbnN0cnVjdG9yKGNhY2hlTmFtZSwgY29uZmlnID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgYXNzZXJ0LmlzVHlwZShjYWNoZU5hbWUsICdzdHJpbmcnLCB7XG4gICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNhY2hlLWV4cGlyYXRpb24nLFxuICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgcGFyYW1OYW1lOiAnY2FjaGVOYW1lJyxcbiAgICAgIH0pO1xuXG4gICAgICBpZiAoIShjb25maWcubWF4RW50cmllcyB8fCBjb25maWcubWF4QWdlU2Vjb25kcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcignbWF4LWVudHJpZXMtb3ItYWdlLXJlcXVpcmVkJywge1xuICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNhY2hlLWV4cGlyYXRpb24nLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLm1heEVudHJpZXMpIHtcbiAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4RW50cmllcywgJ251bWJlcicsIHtcbiAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1jYWNoZS1leHBpcmF0aW9uJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhFbnRyaWVzJyxcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETzogQXNzZXJ0IGlzIHBvc2l0aXZlXG4gICAgICB9XG5cbiAgICAgIGlmIChjb25maWcubWF4QWdlU2Vjb25kcykge1xuICAgICAgICBhc3NlcnQuaXNUeXBlKGNvbmZpZy5tYXhBZ2VTZWNvbmRzLCAnbnVtYmVyJywge1xuICAgICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNhY2hlLWV4cGlyYXRpb24nLFxuICAgICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgICAgZnVuY05hbWU6ICdjb25zdHJ1Y3RvcicsXG4gICAgICAgICAgcGFyYW1OYW1lOiAnY29uZmlnLm1heEFnZVNlY29uZHMnLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPOiBBc3NlcnQgaXMgcG9zaXRpdmVcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IGZhbHNlO1xuICAgIHRoaXMuX21heEVudHJpZXMgPSBjb25maWcubWF4RW50cmllcztcbiAgICB0aGlzLl9tYXhBZ2VTZWNvbmRzID0gY29uZmlnLm1heEFnZVNlY29uZHM7XG4gICAgdGhpcy5fY2FjaGVOYW1lID0gY2FjaGVOYW1lO1xuICAgIHRoaXMuX3RpbWVzdGFtcE1vZGVsID0gbmV3IENhY2hlVGltZXN0YW1wc01vZGVsKGNhY2hlTmFtZSk7XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlcyBlbnRyaWVzIGZvciB0aGUgZ2l2ZW4gY2FjaGUgYW5kIGdpdmVuIGNyaXRlcmlhLlxuICAgKi9cbiAgYXN5bmMgZXhwaXJlRW50cmllcygpIHtcbiAgICBpZiAodGhpcy5faXNSdW5uaW5nKSB7XG4gICAgICB0aGlzLl9yZXJ1blJlcXVlc3RlZCA9IHRydWU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2lzUnVubmluZyA9IHRydWU7XG5cbiAgICBjb25zdCBub3cgPSBEYXRlLm5vdygpO1xuXG4gICAgLy8gRmlyc3QsIGV4cGlyZSBvbGQgZW50cmllcywgaWYgbWF4QWdlU2Vjb25kcyBpcyBzZXQuXG4gICAgY29uc3Qgb2xkRW50cmllcyA9IGF3YWl0IHRoaXMuX2ZpbmRPbGRFbnRyaWVzKG5vdyk7XG5cbiAgICAvLyBPbmNlIHRoYXQncyBkb25lLCBjaGVjayBmb3IgdGhlIG1heGltdW0gc2l6ZS5cbiAgICBjb25zdCBleHRyYUVudHJpZXMgPSBhd2FpdCB0aGlzLl9maW5kRXh0cmFFbnRyaWVzKCk7XG5cbiAgICAvLyBVc2UgYSBTZXQgdG8gcmVtb3ZlIGFueSBkdXBsaWNhdGVzIGZvbGxvd2luZyB0aGUgY29uY2F0ZW5hdGlvbiwgdGhlblxuICAgIC8vIGNvbnZlcnQgYmFjayBpbnRvIGFuIGFycmF5LlxuICAgIGNvbnN0IGFsbFVybHMgPSBbLi4ubmV3IFNldChvbGRFbnRyaWVzLmNvbmNhdChleHRyYUVudHJpZXMpKV07XG5cbiAgICBhd2FpdCBQcm9taXNlLmFsbChbXG4gICAgICB0aGlzLl9kZWxldGVGcm9tQ2FjaGUoYWxsVXJscyksXG4gICAgICB0aGlzLl9kZWxldGVGcm9tSURCKGFsbFVybHMpLFxuICAgIF0pO1xuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIC8vIFRPRE86IGJyZWFrIGFwYXJ0IGVudHJpZXMgZGVsZXRlZCBkdWUgdG8gZXhwaXJhdGlvbiB2cyBzaXplIHJlc3RyYWludHNcbiAgICAgIGlmIChhbGxVcmxzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgbG9nZ2VyLmdyb3VwQ29sbGFwc2VkKFxuICAgICAgICAgIGBFeHBpcmVkICR7YWxsVXJscy5sZW5ndGh9IGAgK1xuICAgICAgICAgIGAke2FsbFVybHMubGVuZ3RoID09PSAxID8gJ2VudHJ5JyA6ICdlbnRyaWVzJ30gYW5kIHJlbW92ZWQgYCArXG4gICAgICAgICAgYCR7YWxsVXJscy5sZW5ndGggPT09IDEgPyAnaXQnIDogJ3RoZW0nfSBmcm9tIHRoZSBgICtcbiAgICAgICAgICBgJyR7dGhpcy5fY2FjaGVOYW1lfScgY2FjaGUuYCk7XG4gICAgICAgIGxvZ2dlci5sb2coXG4gICAgICAgICAgYEV4cGlyZWQgdGhlIGZvbGxvd2luZyAke2FsbFVybHMubGVuZ3RoID09PSAxID8gJ1VSTCcgOiAnVVJMcyd9OmApO1xuICAgICAgICBhbGxVcmxzLmZvckVhY2goKHVybCkgPT4gbG9nZ2VyLmxvZyhgICAgICR7dXJsfWApKTtcbiAgICAgICAgbG9nZ2VyLmdyb3VwRW5kKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsb2dnZXIuZGVidWcoYENhY2hlIGV4cGlyYXRpb24gcmFuIGFuZCBmb3VuZCBubyBlbnRyaWVzIHRvIHJlbW92ZS5gKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLl9pc1J1bm5pbmcgPSBmYWxzZTtcbiAgICBpZiAodGhpcy5fcmVydW5SZXF1ZXN0ZWQpIHtcbiAgICAgIHRoaXMuX3JlcnVuUmVxdWVzdGVkID0gZmFsc2U7XG4gICAgICB0aGlzLmV4cGlyZUVudHJpZXMoKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogRXhwaXJlcyBlbnRyaWVzIGJhc2VkIG9uIHRoZSB0aGUgbWF4aW11bSBhZ2UuXG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBleHBpcmVGcm9tVGltZXN0YW1wIEEgdGltZXN0YW1wLlxuICAgKiBAcmV0dXJuIHtQcm9taXNlPEFycmF5PHN0cmluZz4+fSBBIGxpc3Qgb2YgdGhlIFVSTHMgdGhhdCB3ZXJlIGV4cGlyZWQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhc3luYyBfZmluZE9sZEVudHJpZXMoZXhwaXJlRnJvbVRpbWVzdGFtcCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNUeXBlKGV4cGlyZUZyb21UaW1lc3RhbXAsICdudW1iZXInLCB7XG4gICAgICAgIG1vZHVsZU5hbWU6ICd3b3JrYm94LWNhY2hlLWV4cGlyYXRpb24nLFxuICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb24nLFxuICAgICAgICBmdW5jTmFtZTogJ19maW5kT2xkRW50cmllcycsXG4gICAgICAgIHBhcmFtTmFtZTogJ2V4cGlyZUZyb21UaW1lc3RhbXAnLFxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9tYXhBZ2VTZWNvbmRzKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgZXhwaXJlT2xkZXJUaGFuID0gZXhwaXJlRnJvbVRpbWVzdGFtcCAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCk7XG4gICAgY29uc3QgdGltZXN0YW1wcyA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmdldEFsbFRpbWVzdGFtcHMoKTtcbiAgICBjb25zdCBleHBpcmVkVXJscyA9IFtdO1xuICAgIHRpbWVzdGFtcHMuZm9yRWFjaCgodGltZXN0YW1wRGV0YWlscykgPT4ge1xuICAgICAgaWYgKHRpbWVzdGFtcERldGFpbHMudGltZXN0YW1wIDwgZXhwaXJlT2xkZXJUaGFuKSB7XG4gICAgICAgIGV4cGlyZWRVcmxzLnB1c2godGltZXN0YW1wRGV0YWlscy51cmwpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGV4cGlyZWRVcmxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4ge1Byb21pc2U8QXJyYXk+fVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2ZpbmRFeHRyYUVudHJpZXMoKSB7XG4gICAgY29uc3QgZXh0cmFVcmxzID0gW107XG5cbiAgICBpZiAoIXRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB0aW1lc3RhbXBzID0gYXdhaXQgdGhpcy5fdGltZXN0YW1wTW9kZWwuZ2V0QWxsVGltZXN0YW1wcygpO1xuICAgIHdoaWxlICh0aW1lc3RhbXBzLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgIGNvbnN0IGxhc3RVc2VkID0gdGltZXN0YW1wcy5zaGlmdCgpO1xuICAgICAgZXh0cmFVcmxzLnB1c2gobGFzdFVzZWQudXJsKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZXh0cmFVcmxzO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7QXJyYXk8c3RyaW5nPn0gdXJscyBBcnJheSBvZiBVUkxzIHRvIGRlbGV0ZSBmcm9tIGNhY2hlLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgYXN5bmMgX2RlbGV0ZUZyb21DYWNoZSh1cmxzKSB7XG4gICAgY29uc3QgY2FjaGUgPSBhd2FpdCBjYWNoZXMub3Blbih0aGlzLl9jYWNoZU5hbWUpO1xuICAgIGZvciAoY29uc3QgdXJsIG9mIHVybHMpIHtcbiAgICAgIGF3YWl0IGNhY2hlLmRlbGV0ZSh1cmwpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0FycmF5PHN0cmluZz59IHVybHMgQXJyYXkgb2YgVVJMcyB0byBkZWxldGUgZnJvbSBJREJcbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIF9kZWxldGVGcm9tSURCKHVybHMpIHtcbiAgICBmb3IgKGNvbnN0IHVybCBvZiB1cmxzKSB7XG4gICAgICBhd2FpdCB0aGlzLl90aW1lc3RhbXBNb2RlbC5kZWxldGVVcmwodXJsKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXBkYXRlIHRoZSB0aW1lc3RhbXAgZm9yIHRoZSBnaXZlbiBVUkwuIFRoaXMgZW5zdXJlcyB0aGUgd2hlblxuICAgKiByZW1vdmluZyBlbnRyaWVzIGJhc2VkIG9uIG1heGltdW0gZW50cmllcywgbW9zdCByZWNlbnRseSB1c2VkXG4gICAqIGlzIGFjY3VyYXRlIG9yIHdoZW4gZXhwaXJpbmcsIHRoZSB0aW1lc3RhbXAgaXMgdXAtdG8tZGF0ZS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKi9cbiAgYXN5bmMgdXBkYXRlVGltZXN0YW1wKHVybCkge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBhc3NlcnQuaXNUeXBlKHVybCwgJ3N0cmluZycsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbicsXG4gICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvbicsXG4gICAgICAgIGZ1bmNOYW1lOiAndXBkYXRlVGltZXN0YW1wJyxcbiAgICAgICAgcGFyYW1OYW1lOiAndXJsJyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbik7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSAnJztcblxuICAgIGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLnNldFRpbWVzdGFtcCh1cmxPYmplY3QuaHJlZiwgRGF0ZS5ub3coKSk7XG4gIH1cblxuICAvKipcbiAgICogQ2FuIGJlIHVzZWQgdG8gY2hlY2sgaWYgYSBVUkwgaGFzIGV4cGlyZWQgb3Igbm90IGJlZm9yZSBpdCdzIHVzZWQuXG4gICAqXG4gICAqIFRoaXMgcmVxdWlyZXMgYSBsb29rIHVwIGZyb20gSW5kZXhlZERCLCBzbyBjYW4gYmUgc2xvdy5cbiAgICpcbiAgICogTm90ZTogVGhpcyBtZXRob2Qgd2lsbCBub3QgcmVtb3ZlIHRoZSBjYWNoZWQgZW50cnksIGNhbGxcbiAgICogYGV4cGlyZUVudHJpZXMoKWAgdG8gcmVtb3ZlIGluZGV4ZWREQiBhbmQgQ2FjaGUgZW50cmllcy5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHVybFxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgYXN5bmMgaXNVUkxFeHBpcmVkKHVybCkge1xuICAgIGlmICghdGhpcy5fbWF4QWdlU2Vjb25kcykge1xuICAgICAgdGhyb3cgbmV3IFdvcmtib3hFcnJvcihgZXhwaXJlZC10ZXN0LXdpdGhvdXQtbWF4LWFnZWAsIHtcbiAgICAgICAgbWV0aG9kTmFtZTogJ2lzVVJMRXhwaXJlZCcsXG4gICAgICAgIHBhcmFtTmFtZTogJ21heEFnZVNlY29uZHMnLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGNvbnN0IHVybE9iamVjdCA9IG5ldyBVUkwodXJsLCBsb2NhdGlvbik7XG4gICAgdXJsT2JqZWN0Lmhhc2ggPSAnJztcblxuICAgIGNvbnN0IHRpbWVzdGFtcCA9IGF3YWl0IHRoaXMuX3RpbWVzdGFtcE1vZGVsLmdldFRpbWVzdGFtcCh1cmxPYmplY3QuaHJlZik7XG4gICAgY29uc3QgZXhwaXJlT2xkZXJUaGFuID0gRGF0ZS5ub3coKSAtICh0aGlzLl9tYXhBZ2VTZWNvbmRzICogMTAwMCk7XG4gICAgcmV0dXJuICh0aW1lc3RhbXAgPCBleHBpcmVPbGRlclRoYW4pO1xuICB9XG59XG5cbmV4cG9ydCB7Q2FjaGVFeHBpcmF0aW9ufTtcbiIsIi8qXG4gQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4qL1xuXG5pbXBvcnQge1dvcmtib3hFcnJvcn0gZnJvbSAnd29ya2JveC1jb3JlL19wcml2YXRlL1dvcmtib3hFcnJvci5tanMnO1xuaW1wb3J0IHthc3NlcnR9IGZyb20gJ3dvcmtib3gtY29yZS9fcHJpdmF0ZS9hc3NlcnQubWpzJztcbmltcG9ydCB7Q2FjaGVFeHBpcmF0aW9ufSBmcm9tICcuL0NhY2hlRXhwaXJhdGlvbi5tanMnO1xuaW1wb3J0ICcuL192ZXJzaW9uLm1qcyc7XG5cbi8qKlxuICogVGhpcyBwbHVnaW4gY2FuIGJlIHVzZWQgaW4gdGhlIFdvcmtib3ggQVBJJ3MgdG8gcmVndWxhcmx5IGVuZm9yY2UgYVxuICogbGltaXQgb24gdGhlIGFnZSBhbmQgLyBvciB0aGUgbnVtYmVyIG9mIGNhY2hlZCByZXF1ZXN0cy5cbiAqXG4gKiBXaGVuZXZlciBhIGNhY2hlZCByZXF1ZXN0IGlzIHVzZWQgb3IgdXBkYXRlZCwgdGhpcyBwbHVnaW4gd2lsbCBsb29rXG4gKiBhdCB0aGUgdXNlZCBDYWNoZSBhbmQgcmVtb3ZlIGFueSBvbGQgb3IgZXh0cmEgcmVxdWVzdHMuXG4gKlxuICogV2hlbiB1c2luZyBgbWF4QWdlU2Vjb25kc2AsIHJlcXVlc3RzIG1heSBiZSB1c2VkICpvbmNlKiBhZnRlciBleHBpcmluZ1xuICogYmVjYXVzZSB0aGUgZXhwaXJhdGlvbiBjbGVhbiB1cCB3aWxsIG5vdCBoYXZlIG9jY3VyZWQgdW50aWwgKmFmdGVyKiB0aGVcbiAqIGNhY2hlZCByZXF1ZXN0IGhhcyBiZWVuIHVzZWQuIElmIHRoZSByZXF1ZXN0IGhhcyBhIFwiRGF0ZVwiIGhlYWRlciwgdGhlblxuICogYSBsaWdodCB3ZWlnaHQgZXhwaXJhdGlvbiBjaGVjayBpcyBwZXJmb3JtZWQgYW5kIHRoZSByZXF1ZXN0IHdpbGwgbm90IGJlXG4gKiB1c2VkIGltbWVkaWF0ZWx5LlxuICpcbiAqIFdoZW4gdXNpbmcgYG1heEVudHJpZXNgLCB0aGUgbGFzdCByZXF1ZXN0IHRvIGJlIHVzZWQgd2lsbCBiZSB0aGUgcmVxdWVzdFxuICogdGhhdCBpcyByZW1vdmVkIGZyb20gdGhlIENhY2hlLlxuICpcbiAqIEBtZW1iZXJvZiB3b3JrYm94LmV4cGlyYXRpb25cbiAqL1xuY2xhc3MgQ2FjaGVFeHBpcmF0aW9uUGx1Z2luIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWdcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtjb25maWcubWF4RW50cmllc10gVGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgdG8gY2FjaGUuXG4gICAqIEVudHJpZXMgdXNlZCB0aGUgbGVhc3Qgd2lsbCBiZSByZW1vdmVkIGFzIHRoZSBtYXhpbXVtIGlzIHJlYWNoZWQuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY29uZmlnLm1heEFnZVNlY29uZHNdIFRoZSBtYXhpbXVtIGFnZSBvZiBhbiBlbnRyeSBiZWZvcmVcbiAgICogaXQncyB0cmVhdGVkIGFzIHN0YWxlIGFuZCByZW1vdmVkLlxuICAgKi9cbiAgY29uc3RydWN0b3IoY29uZmlnID0ge30pIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCEoY29uZmlnLm1heEVudHJpZXMgfHwgY29uZmlnLm1heEFnZVNlY29uZHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBXb3JrYm94RXJyb3IoJ21heC1lbnRyaWVzLW9yLWFnZS1yZXF1aXJlZCcsIHtcbiAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1jYWNoZS1leHBpcmF0aW9uJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb25QbHVnaW4nLFxuICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgaWYgKGNvbmZpZy5tYXhFbnRyaWVzKSB7XG4gICAgICAgIGFzc2VydC5pc1R5cGUoY29uZmlnLm1heEVudHJpZXMsICdudW1iZXInLCB7XG4gICAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbicsXG4gICAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uUGx1Z2luJyxcbiAgICAgICAgICBmdW5jTmFtZTogJ2NvbnN0cnVjdG9yJyxcbiAgICAgICAgICBwYXJhbU5hbWU6ICdjb25maWcubWF4RW50cmllcycsXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICBpZiAoY29uZmlnLm1heEFnZVNlY29uZHMpIHtcbiAgICAgICAgYXNzZXJ0LmlzVHlwZShjb25maWcubWF4QWdlU2Vjb25kcywgJ251bWJlcicsIHtcbiAgICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1jYWNoZS1leHBpcmF0aW9uJyxcbiAgICAgICAgICBjbGFzc05hbWU6ICdDYWNoZUV4cGlyYXRpb25QbHVnaW4nLFxuICAgICAgICAgIGZ1bmNOYW1lOiAnY29uc3RydWN0b3InLFxuICAgICAgICAgIHBhcmFtTmFtZTogJ2NvbmZpZy5tYXhBZ2VTZWNvbmRzJyxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5fY29uZmlnID0gY29uZmlnO1xuICAgIHRoaXMuX21heEFnZVNlY29uZHMgPSBjb25maWcubWF4QWdlU2Vjb25kcztcbiAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zID0gbmV3IE1hcCgpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc2ltcGxlIGhlbHBlciBtZXRob2QgdG8gcmV0dXJuIGEgQ2FjaGVFeHBpcmF0aW9uIGluc3RhbmNlIGZvciBhIGdpdmVuXG4gICAqIGNhY2hlIG5hbWUuXG4gICAqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjYWNoZU5hbWVcbiAgICogQHJldHVybiB7Q2FjaGVFeHBpcmF0aW9ufVxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpIHtcbiAgICBsZXQgY2FjaGVFeHBpcmF0aW9uID0gdGhpcy5fY2FjaGVFeHBpcmF0aW9ucy5nZXQoY2FjaGVOYW1lKTtcbiAgICBpZiAoIWNhY2hlRXhwaXJhdGlvbikge1xuICAgICAgY2FjaGVFeHBpcmF0aW9uID0gbmV3IENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUsIHRoaXMuX2NvbmZpZyk7XG4gICAgICB0aGlzLl9jYWNoZUV4cGlyYXRpb25zLnNldChjYWNoZU5hbWUsIGNhY2hlRXhwaXJhdGlvbik7XG4gICAgfVxuICAgIHJldHVybiBjYWNoZUV4cGlyYXRpb247XG4gIH1cblxuICAvKipcbiAgICogQSBcImxpZmVjeWNsZVwiIGNhbGxiYWNrIHRoYXQgd2lsbCBiZSB0cmlnZ2VyZWQgYXV0b21hdGljYWxseSBieSB0aGVcbiAgICogYHdvcmtib3gucnVudGltZUNhY2hpbmdgIGhhbmRsZXJzIHdoZW4gYSBgUmVzcG9uc2VgIGlzIGFib3V0IHRvIGJlIHJldHVybmVkXG4gICAqIGZyb20gYSBbQ2FjaGVdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DYWNoZSkgdG9cbiAgICogdGhlIGhhbmRsZXIuIEl0IGFsbG93cyB0aGUgYFJlc3BvbnNlYCB0byBiZSBpbnNwZWN0ZWQgZm9yIGZyZXNobmVzcyBhbmRcbiAgICogcHJldmVudHMgaXQgZnJvbSBiZWluZyB1c2VkIGlmIHRoZSBgUmVzcG9uc2VgJ3MgYERhdGVgIGhlYWRlciB2YWx1ZSBpc1xuICAgKiBvbGRlciB0aGFuIHRoZSBjb25maWd1cmVkIGBtYXhBZ2VTZWNvbmRzYC5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IGlucHV0XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBpbnB1dC5jYWNoZU5hbWUgTmFtZSBvZiB0aGUgY2FjaGUgdGhlIHJlc3BvbnNlcyBiZWxvbmcgdG8uXG4gICAqIEBwYXJhbSB7UmVzcG9uc2V9IGlucHV0LmNhY2hlZFJlc3BvbnNlIFRoZSBgUmVzcG9uc2VgIG9iamVjdCB0aGF0J3MgYmVlblxuICAgKiAgICAgICAgcmVhZCBmcm9tIGEgY2FjaGUgYW5kIHdob3NlIGZyZXNobmVzcyBzaG91bGQgYmUgY2hlY2tlZC5cbiAgICogQHJldHVybiB7UmVzcG9uc2V9IEVpdGhlciB0aGUgYGNhY2hlZFJlc3BvbnNlYCwgaWYgaXQnc1xuICAgKiAgICAgICAgIGZyZXNoLCBvciBgbnVsbGAgaWYgdGhlIGBSZXNwb25zZWAgaXMgb2xkZXIgdGhhbiBgbWF4QWdlU2Vjb25kc2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBjYWNoZWRSZXNwb25zZVdpbGxCZVVzZWQoe2NhY2hlTmFtZSwgY2FjaGVkUmVzcG9uc2V9KSB7XG4gICAgbGV0IGlzRnJlc2ggPSB0aGlzLl9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKTtcblxuICAgIC8vIEV4cGlyZSBlbnRyaWVzIHRvIGVuc3VyZSB0aGF0IGV2ZW4gaWYgdGhlIGV4cGlyYXRpb24gZGF0ZSBoYXNcbiAgICAvLyBleHBpcmVkLCBpdCdsbCBvbmx5IGJlIHVzZWQgb25jZS5cbiAgICBjb25zdCBjYWNoZUV4cGlyYXRpb24gPSB0aGlzLl9nZXRDYWNoZUV4cGlyYXRpb24oY2FjaGVOYW1lKTtcbiAgICBjYWNoZUV4cGlyYXRpb24uZXhwaXJlRW50cmllcygpO1xuXG4gICAgcmV0dXJuIGlzRnJlc2ggPyBjYWNoZWRSZXNwb25zZSA6IG51bGw7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtSZXNwb25zZX0gY2FjaGVkUmVzcG9uc2VcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIF9pc1Jlc3BvbnNlRGF0ZUZyZXNoKGNhY2hlZFJlc3BvbnNlKSB7XG4gICAgaWYgKCF0aGlzLl9tYXhBZ2VTZWNvbmRzKSB7XG4gICAgICAvLyBXZSBhcmVuJ3QgZXhwaXJpbmcgYnkgYWdlLCBzbyByZXR1cm4gdHJ1ZSwgaXQncyBmcmVzaFxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgaWYgdGhlICdkYXRlJyBoZWFkZXIgd2lsbCBzdWZmaWNlIGEgcXVpY2sgZXhwaXJhdGlvbiBjaGVjay5cbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL0dvb2dsZUNocm9tZUxhYnMvc3ctdG9vbGJveC9pc3N1ZXMvMTY0IGZvclxuICAgIC8vIGRpc2N1c3Npb24uXG4gICAgY29uc3QgZGF0ZUhlYWRlclRpbWVzdGFtcCA9IHRoaXMuX2dldERhdGVIZWFkZXJUaW1lc3RhbXAoY2FjaGVkUmVzcG9uc2UpO1xuICAgIGlmIChkYXRlSGVhZGVyVGltZXN0YW1wID09PSBudWxsKSB7XG4gICAgICAvLyBVbmFibGUgdG8gcGFyc2UgZGF0ZSwgc28gYXNzdW1lIGl0J3MgZnJlc2guXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBJZiB3ZSBoYXZlIGEgdmFsaWQgaGVhZGVyVGltZSwgdGhlbiBvdXIgcmVzcG9uc2UgaXMgZnJlc2ggaWZmIHRoZVxuICAgIC8vIGhlYWRlclRpbWUgcGx1cyBtYXhBZ2VTZWNvbmRzIGlzIGdyZWF0ZXIgdGhhbiB0aGUgY3VycmVudCB0aW1lLlxuICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgcmV0dXJuIGRhdGVIZWFkZXJUaW1lc3RhbXAgPj0gbm93IC0gKHRoaXMuX21heEFnZVNlY29uZHMgKiAxMDAwKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIG1ldGhvZCB3aWxsIGV4dHJhY3QgdGhlIGRhdGEgaGVhZGVyIGFuZCBwYXJzZSBpdCBpbnRvIGEgdXNlZnVsXG4gICAqIHZhbHVlLlxuICAgKlxuICAgKiBAcGFyYW0ge1Jlc3BvbnNlfSBjYWNoZWRSZXNwb25zZVxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBfZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcChjYWNoZWRSZXNwb25zZSkge1xuICAgIGNvbnN0IGRhdGVIZWFkZXIgPSBjYWNoZWRSZXNwb25zZS5oZWFkZXJzLmdldCgnZGF0ZScpO1xuICAgIGNvbnN0IHBhcnNlZERhdGUgPSBuZXcgRGF0ZShkYXRlSGVhZGVyKTtcbiAgICBjb25zdCBoZWFkZXJUaW1lID0gcGFyc2VkRGF0ZS5nZXRUaW1lKCk7XG5cbiAgICAvLyBJZiB0aGUgRGF0ZSBoZWFkZXIgd2FzIGludmFsaWQgZm9yIHNvbWUgcmVhc29uLCBwYXJzZWREYXRlLmdldFRpbWUoKVxuICAgIC8vIHdpbGwgcmV0dXJuIE5hTi5cbiAgICBpZiAoaXNOYU4oaGVhZGVyVGltZSkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBoZWFkZXJUaW1lO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgXCJsaWZlY3ljbGVcIiBjYWxsYmFjayB0aGF0IHdpbGwgYmUgdHJpZ2dlcmVkIGF1dG9tYXRpY2FsbHkgYnkgdGhlXG4gICAqIGB3b3JrYm94LnJ1bnRpbWVDYWNoaW5nYCBoYW5kbGVycyB3aGVuIGFuIGVudHJ5IGlzIGFkZGVkIHRvIGEgY2FjaGUuXG4gICAqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBpbnB1dFxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQuY2FjaGVOYW1lIE5hbWUgb2YgdGhlIGNhY2hlIHRoZSByZXNwb25zZXMgYmVsb25nIHRvLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gaW5wdXQucmVxdWVzdCBUaGUgUmVxdWVzdCBmb3IgdGhlIGNhY2hlZCBlbnRyeS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFzeW5jIGNhY2hlRGlkVXBkYXRlKHtjYWNoZU5hbWUsIHJlcXVlc3R9KSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGFzc2VydC5pc1R5cGUoY2FjaGVOYW1lLCAnc3RyaW5nJywge1xuICAgICAgICBtb2R1bGVOYW1lOiAnd29ya2JveC1jYWNoZS1leHBpcmF0aW9uJyxcbiAgICAgICAgY2xhc3NOYW1lOiAnQ2FjaGVFeHBpcmF0aW9uUGx1Z2luJyxcbiAgICAgICAgZnVuY05hbWU6ICdjYWNoZURpZFVwZGF0ZScsXG4gICAgICAgIHBhcmFtTmFtZTogJ2NhY2hlTmFtZScsXG4gICAgICB9KTtcbiAgICAgIGFzc2VydC5pc0luc3RhbmNlKHJlcXVlc3QsIFJlcXVlc3QsIHtcbiAgICAgICAgbW9kdWxlTmFtZTogJ3dvcmtib3gtY2FjaGUtZXhwaXJhdGlvbicsXG4gICAgICAgIGNsYXNzTmFtZTogJ0NhY2hlRXhwaXJhdGlvblBsdWdpbicsXG4gICAgICAgIGZ1bmNOYW1lOiAnY2FjaGVEaWRVcGRhdGUnLFxuICAgICAgICBwYXJhbU5hbWU6ICdyZXF1ZXN0JyxcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IGNhY2hlRXhwaXJhdGlvbiA9IHRoaXMuX2dldENhY2hlRXhwaXJhdGlvbihjYWNoZU5hbWUpO1xuICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi51cGRhdGVUaW1lc3RhbXAocmVxdWVzdC51cmwpO1xuICAgIGF3YWl0IGNhY2hlRXhwaXJhdGlvbi5leHBpcmVFbnRyaWVzKCk7XG4gIH1cbn1cblxuZXhwb3J0IHtDYWNoZUV4cGlyYXRpb25QbHVnaW59O1xuIl0sIm5hbWVzIjpbIndvcmtib3giLCJ2IiwiZSIsIkNhY2hlVGltZXN0YW1wc01vZGVsIiwiY2FjaGVOYW1lIiwiX2NhY2hlTmFtZSIsIl9zdG9yZU5hbWUiLCJfZGIiLCJEQldyYXBwZXIiLCJldnQiLCJ0YXJnZXQiLCJyZXN1bHQiLCJjcmVhdGVPYmplY3RTdG9yZSIsInRoaXMiLCJrZXlQYXRoIiwiY3JlYXRlSW5kZXgiLCJ1bmlxdWUiLCJ1cmwiLCJ0aW1lc3RhbXAiLCJfdGhpcyIsInB1dCIsIlVSTCIsImxvY2F0aW9uIiwiaHJlZiIsIl90aGlzMiIsImdldEFsbE1hdGNoaW5nIiwiX3RoaXMzIiwiZ2V0IiwiX3RoaXM0IiwiZGVsZXRlIiwiQ2FjaGVFeHBpcmF0aW9uIiwiY29uZmlnIiwiX2lzUnVubmluZyIsIl9yZXJ1blJlcXVlc3RlZCIsIl9tYXhFbnRyaWVzIiwibWF4RW50cmllcyIsIl9tYXhBZ2VTZWNvbmRzIiwibWF4QWdlU2Vjb25kcyIsIl90aW1lc3RhbXBNb2RlbCIsIm5vdyIsIkRhdGUiLCJvbGRFbnRyaWVzIiwiX2ZpbmRPbGRFbnRyaWVzIiwiZXh0cmFFbnRyaWVzIiwiX2ZpbmRFeHRyYUVudHJpZXMiLCJhbGxVcmxzIiwiU2V0IiwiY29uY2F0IiwiUHJvbWlzZSIsImFsbCIsIl9kZWxldGVGcm9tQ2FjaGUiLCJfZGVsZXRlRnJvbUlEQiIsImV4cGlyZUVudHJpZXMiLCJleHBpcmVGcm9tVGltZXN0YW1wIiwiZXhwaXJlT2xkZXJUaGFuIiwiZXhwaXJlZFVybHMiLCJnZXRBbGxUaW1lc3RhbXBzIiwiZm9yRWFjaCIsInRpbWVzdGFtcERldGFpbHMiLCJwdXNoIiwiZXh0cmFVcmxzIiwidGltZXN0YW1wcyIsImxlbmd0aCIsImxhc3RVc2VkIiwic2hpZnQiLCJ1cmxzIiwiY2FjaGUiLCJjYWNoZXMiLCJvcGVuIiwiX3RoaXM1IiwiZGVsZXRlVXJsIiwidXJsT2JqZWN0IiwiaGFzaCIsIl90aGlzNiIsInNldFRpbWVzdGFtcCIsIl90aGlzNyIsIldvcmtib3hFcnJvciIsImdldFRpbWVzdGFtcCIsIkNhY2hlRXhwaXJhdGlvblBsdWdpbiIsIl9jb25maWciLCJfY2FjaGVFeHBpcmF0aW9ucyIsIk1hcCIsImNhY2hlRXhwaXJhdGlvbiIsInNldCIsImNhY2hlZFJlc3BvbnNlIiwiaXNGcmVzaCIsIl9pc1Jlc3BvbnNlRGF0ZUZyZXNoIiwiX2dldENhY2hlRXhwaXJhdGlvbiIsImRhdGVIZWFkZXJUaW1lc3RhbXAiLCJfZ2V0RGF0ZUhlYWRlclRpbWVzdGFtcCIsImRhdGVIZWFkZXIiLCJoZWFkZXJzIiwiaGVhZGVyVGltZSIsImdldFRpbWUiLCJpc05hTiIsInJlcXVlc3QiLCJ1cGRhdGVUaW1lc3RhbXAiXSwibWFwcGluZ3MiOiJtRkFBQSxTQUFTQSxRQUFRQyxFQUFFLDBDQUEwQyxFQUFHLE1BQU1DLFVDMkJoRUMsY0FPUUMsUUFHTEMsRUFBYUQsT0FDYkUsRUFBYUYsT0FFYkcsRUFBTSxJQUFJQyxZQUFVLDJCQUE0QixtQkFDakNDLEdBQVFBLEVBQUlDLE9BQU9DLE9BQ2hDQyxrQkFBa0JDLEtBQUtQLEdBQWFRLFFBdkIvQixRQXdCTEMsWUF2QlcsWUFBQSxhQXVCZ0NDLFFBQVEsbUJBVXpDQyxFQUFLQyxxRUFDaEJDLEVBQUtaLEVBQUlhLElBQUlELEVBQUtiLE9BQ1gsSUFBSWUsSUFBSUosRUFBS0ssVUFBVUMsZUFDakJMLG9HQVlOTSxFQUFLakIsRUFBSWtCLGVBQWVELEVBQUtsQixTQWhEeEIsK0JBNkREVyw0RUFDYVMsRUFBS25CLEVBQUlvQixJQUFJRCxFQUFLcEIsRUFBWVcsSUFDckNDLHdCQVFURCxxRUFDUlcsRUFBS3JCLEVBQUlzQixPQUFPRCxFQUFLdEIsRUFBWSxJQUFJZSxJQUFJSixFQUFLSyxVQUFVQyxpQkMvRDVETyxjQVlRMUIsRUFBVzJCLFdBd0NoQkMsR0FBYSxPQUNiQyxHQUFrQixPQUNsQkMsRUFBY0gsRUFBT0ksZ0JBQ3JCQyxFQUFpQkwsRUFBT00sbUJBQ3hCaEMsRUFBYUQsT0FDYmtDLEVBQWtCLElBQUluQyxFQUFxQkMsa0ZBTzVDZSxFQUFLYSxnQkFDRkMsR0FBa0IsS0FHcEJELEdBQWEsUUFFWk8sRUFBTUMsS0FBS0QsTUFHWEUsUUFBbUJ0QixFQUFLdUIsRUFBZ0JILEdBR3hDSSxRQUFxQnhCLEVBQUt5QixJQUkxQkMsTUFBYyxJQUFJQyxJQUFJTCxFQUFXTSxPQUFPSixXQUV4Q0ssUUFBUUMsS0FDWjlCLEVBQUsrQixFQUFpQkwsR0FDdEIxQixFQUFLZ0MsRUFBZU4sT0FvQmpCYixHQUFhLEVBQ2RiLEVBQUtjLE1BQ0ZBLEdBQWtCLElBQ2xCbUIsdUJBWWFDLG1FQVVmN0IsRUFBS1ksaUJBSUprQixFQUFrQkQsRUFBNkMsSUFBdEI3QixFQUFLWSxFQUU5Q21CLGtCQURtQi9CLEVBQUtjLEVBQWdCa0Isb0JBRW5DQyxRQUFRLFNBQUNDLEdBQ2RBLEVBQWlCeEMsVUFBWW9DLEtBQ25CSyxLQUFLRCxFQUFpQnpDLE9BSS9Cc0MsNEVBU0RLLFNBRURsQyxFQUFLUSxpQkFJSjJCLFFBQW1CbkMsRUFBS1ksRUFBZ0JrQix3QkFDdkNLLEVBQVdDLE9BQVNwQyxFQUFLUSxHQUFhLE9BQ3JDNkIsRUFBV0YsRUFBV0csVUFDbEJMLEtBQUtJLEVBQVM5QyxZQUduQjJDLFFBUWNLLHFFQUNmQyxRQUFjQyxPQUFPQyxLQUFLeEMsRUFBS3ZCLE9BQ2hDLE1BQU1ZLEtBQU9nRCxRQUNWQyxFQUFNckMsT0FBT1osU0FTRmdELG1FQUNkLE1BQU1oRCxLQUFPZ0QsUUFDVkksRUFBSy9CLEVBQWdCZ0MsVUFBVXJELHVCQVduQkEscUVBVWRzRCxFQUFZLElBQUlsRCxJQUFJSixFQUFLSyxZQUNyQmtELEtBQU8sU0FFWEMsRUFBS25DLEVBQWdCb0MsYUFBYUgsRUFBVWhELEtBQU1pQixLQUFLRCx3QkFjNUN0QixtRUFDWjBELEVBQUt2QyxRQUNGLElBQUl3QyxlQUFjLDJDQUNWLHlCQUNELHdCQUdUTCxFQUFZLElBQUlsRCxJQUFJSixFQUFLSyxtQkFDckJrRCxLQUFPLFVBRU9HLEVBQUtyQyxFQUFnQnVDLGFBQWFOLEVBQVVoRCxPQUM1Q2lCLEtBQUtELE1BQStCLElBQXRCb0MsRUFBS3ZDLGFDbk96QzBDLGNBUVEvQyxXQTZCTGdELEVBQVVoRCxPQUNWSyxFQUFpQkwsRUFBT00sbUJBQ3hCMkMsRUFBb0IsSUFBSUMsTUFZWDdFLE9BQ2Q4RSxFQUFrQnJFLEtBQUttRSxFQUFrQnJELElBQUl2QixVQUM1QzhFLE1BQ2UsSUFBSXBELEVBQWdCMUIsRUFBV1MsS0FBS2tFLFFBQ2pEQyxFQUFrQkcsSUFBSS9FLEVBQVc4RSxJQUVqQ0EsNEJBb0JnQjlFLFVBQUNBLEVBQURnRixlQUFZQSxRQUMvQkMsRUFBVXhFLEtBQUt5RSxFQUFxQkYsVUFJaEJ2RSxLQUFLMEUsRUFBb0JuRixHQUNqQ2dELGdCQUVUaUMsRUFBVUQsRUFBaUIsT0FTZkEsT0FDZHZFLEtBQUt1QixTQUVELFFBTUhvRCxFQUFzQjNFLEtBQUs0RSxFQUF3QkwsVUFDN0IsT0FBeEJJLEdBUUdBLEdBREtoRCxLQUFLRCxNQUMwQyxJQUF0QjFCLEtBQUt1QixJQVlwQmdELFNBQ2hCTSxFQUFhTixFQUFlTyxRQUFRaEUsSUFBSSxRQUV4Q2lFLEVBRGEsSUFBSXBELEtBQUtrRCxHQUNFRyxpQkFJMUJDLE1BQU1GLEdBQ0QsS0FHRkEsa0JBYVl4RixVQUFDQSxFQUFEMkYsUUFBWUEsc0VBZ0J6QmIsRUFBa0IvRCxFQUFLb0UsRUFBb0JuRixTQUMzQzhFLEVBQWdCYyxnQkFBZ0JELEVBQVE5RSxXQUN4Q2lFLEVBQWdCOUIifQ=="}